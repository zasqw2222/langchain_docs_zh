---
title: 代理框架能力
sidebarTitle: 代理框架
---

我们将 `deepagents` 视为一个"代理框架"。它与其他代理框架具有相同的核心工具调用循环，但具有内置工具和能力。

本页列出了构成代理框架的组件。

## 文件系统访问

框架提供六个文件系统操作工具，使文件成为代理环境中的一等公民：

| 工具 | 描述 |
|---|---|
| `ls` | 列出目录中的文件及其元数据（大小、修改时间） |
| `read_file` | 读取带行号的文件内容，支持大文件的偏移/限制 |
| `write_file` | 创建新文件 |
| `edit_file` | 在文件中执行精确字符串替换（支持全局替换模式） |
| `glob` | 查找匹配模式的文件（例如，`**/*.py`） |
| `grep` | 使用多种输出模式搜索文件内容（仅文件、带上下文的内容或计数） |


## 大型工具结果驱逐

当工具结果超过令牌阈值时，框架会自动将大型工具结果转储到文件系统，防止上下文窗口饱和。

**工作原理：**

- 监控工具调用结果的大小（默认阈值：20,000 令牌）
- 超过阈值时，将结果写入文件
- 用简洁的文件引用替换工具结果
- 代理可以在需要时稍后读取文件

## 可插拔存储后端

框架将文件系统操作抽象到协议后面，允许针对不同用例使用不同的存储策略。

**可用后端：**

1. **StateBackend** - 临时内存存储
   - 文件存在于代理状态中（与对话一起检查点）
   - 在线程内持久化，但不在线程间持久化
   - 适用于临时工作文件

2. **FilesystemBackend** - 真实文件系统访问
   - 从实际磁盘读取/写入
   - 支持虚拟模式（沙箱化到根目录）
   - 与系统工具集成（使用 ripgrep 进行 grep）
   - 安全功能：路径验证、大小限制、符号链接防护

3. **StoreBackend** - 持久化跨对话存储
   - 使用 LangGraph 的 BaseStore 实现持久化
   - 按 assistant_id 命名空间
   - 文件在对话之间持久化
   - 适用于长期记忆或知识库

4. **CompositeBackend** - 将不同路径路由到不同后端
   - 示例：`/` → StateBackend，`/memories/` → StoreBackend
   - 最长前缀匹配进行路由
   - 支持混合存储策略

## 任务委托（子代理）

框架允许主代理为隔离的多步骤任务创建临时"子代理"。

**为什么有用：**
- **上下文隔离** - 子代理的工作不会使主代理的上下文混乱
- **并行执行** - 多个子代理可以并发运行
- **专业化** - 子代理可以有不同的工具/配置
- **令牌效率** - 大型子任务上下文被压缩为单个结果

**工作原理：**
- 主代理有一个 `task` 工具
- 调用时，创建一个具有自己上下文的新代理实例
- 子代理自主执行直到完成
- 向主代理返回单个最终报告
- 子代理是无状态的（无法发送多条消息）

**默认子代理：**
- "general-purpose" 子代理自动可用
- 默认具有文件系统工具
- 可以使用其他工具/中间件进行自定义

**自定义子代理：**
- 定义具有特定工具的专业子代理
- 示例：代码审查者、网络研究员、测试运行器
- 通过 `subagents` 参数配置

## 对话历史摘要

当令牌使用过多时，框架会自动压缩旧的对话历史。

**配置：**
- 在 170,000 令牌时触发
- 保持最近 6 条消息完整
- 较旧的消息由模型摘要

**为什么有用：**
- 支持非常长的对话而不会达到上下文限制
- 在压缩历史记录的同时保留最近的上下文
- 对代理透明（显示为特殊系统消息）

## 悬空工具调用修复

当工具调用在接收结果之前被中断或取消时，框架会修复消息历史。

**问题：**
- 代理请求工具调用："请运行 X"
- 工具调用被中断（用户取消、错误等）
- 代理在 AIMessage 中看到 tool_call，但没有相应的 ToolMessage
- 这创建了无效的消息序列

**解决方案：**
- 检测没有结果的 tool_calls 的 AIMessages
- 创建合成 ToolMessage 响应，指示调用已取消
- 在代理执行之前修复消息历史

**为什么有用：**
- 防止代理因不完整的消息链而混淆
- 优雅地处理中断和错误
- 保持对话连贯性

## 待办事项列表跟踪

框架提供一个 `write_todos` 工具，代理可以使用它来维护结构化的任务列表。

**功能：**
- 跟踪具有状态（pending、in_progress、completed）的多个任务
- 在代理状态中持久化
- 帮助代理组织复杂的多步骤工作
- 适用于长时间运行的任务和规划


## 人在回路

框架在指定的工具调用处暂停代理执行，以允许人工审批/修改。

**配置：**
- 将工具名称映射到中断配置
- 示例：`{"edit_file": True}` - 每次编辑前暂停
- 可以提供审批消息或修改工具输入

**为什么有用：**
- 破坏性操作的安全门
- 在昂贵的 API 调用之前进行用户验证
- 交互式调试和指导


## 提示缓存（Anthropic）

框架启用 Anthropic 的提示缓存功能，以减少冗余令牌处理。

**工作原理：**
- 缓存跨轮次重复的提示部分
- 显著减少长系统提示的延迟和成本
- 对于非 Anthropic 模型自动跳过

**为什么有用：**
- 系统提示（特别是带有文件系统文档的）可能超过 5k 令牌
- 这些在没有缓存的情况下每轮都会重复
- 缓存提供约 10 倍的加速和成本降低

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\deepagents\harness.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
