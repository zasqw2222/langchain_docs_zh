---
title: Deep Agents 中间件
sidebarTitle: 中间件
description: 了解驱动深度代理的中间件
---

深度代理使用模块化中间件架构构建。深度代理可以访问：

1. 规划工具
2. 用于存储上下文和长期记忆的文件系统
3. 生成子代理的能力

每个功能都作为单独的中间件实现。当您使用 `create_deep_agent` 创建深度代理时，我们会自动将 `TodoListMiddleware`、`FilesystemMiddleware` 和 `SubAgentMiddleware` 附加到您的代理。

中间件是可组合的——您可以根据需要向代理添加或多或少的中间件。您可以独立使用任何中间件。

以下部分说明每个中间件提供的内容。

## 待办事项列表中间件

规划是解决复杂问题的关键。如果您最近使用过 Claude Code，您会注意到它在处理复杂的多部分任务之前如何写出待办事项列表。您还会注意到它如何在获得更多信息时实时适应和更新此待办事项列表。

`TodoListMiddleware` 为您的代理提供一个专门用于更新此待办事项列表的工具。在执行多部分任务之前和期间，代理会被提示使用 `write_todos` 工具来跟踪它正在做什么以及仍需要做什么。



```typescript
import { createAgent, todoListMiddleware } from "langchain";

// todoListMiddleware 默认包含在 createDeepAgent 中
// 如果构建自定义代理，可以自定义它
const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  middleware: [
    todoListMiddleware({
      // 可选：系统提示的自定义添加
      systemPrompt: "Use the write_todos tool to...",
    }),
  ],
});
```


## 文件系统中间件

上下文工程是构建有效代理的主要挑战。在使用返回可变长度结果的工具（例如，web_search 和 rag）时尤其困难，因为长工具结果会快速填满您的上下文窗口。

`FilesystemMiddleware` 提供四个工具，用于与短期和长期内存交互：

- **ls**：列出文件系统中的文件
- **read_file**：读取整个文件或文件中的一定行数
- **write_file**：向文件系统写入新文件
- **edit_file**：编辑文件系统中的现有文件



```typescript
import { createAgent } from "langchain";
import { createFilesystemMiddleware } from "deepagents";

// FilesystemMiddleware is included by default in createDeepAgent
// You can customize it if building a custom agent
const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  middleware: [
    createFilesystemMiddleware({
      backend: undefined,  // 可选：自定义后端（默认为 StateBackend）
      systemPrompt: "Write to the filesystem when...",  // 可选的系统提示覆盖
      customToolDescriptions: {
        ls: "Use the ls tool when...",
        read_file: "Use the read_file tool to...",
      },  // 可选：文件系统工具的自定义描述
    }),
  ],
});
```


### 短期与长期文件系统

默认情况下，这些工具写入您的图状态中的本地"文件系统"。要启用跨线程的持久化存储，请配置一个将特定路径（如 `/memories/`）路由到 `StoreBackend` 的 `CompositeBackend`。



```typescript
import { createAgent } from "langchain";
import { createFilesystemMiddleware, CompositeBackend, StateBackend, StoreBackend } from "deepagents";
import { InMemoryStore } from "@langchain/langgraph-checkpoint";

const store = new InMemoryStore();

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  store,
  middleware: [
    createFilesystemMiddleware({
      backend: (config) => new CompositeBackend(
        new StateBackend(config),
        { "/memories/": new StoreBackend(config) }
      ),
      systemPrompt: "Write to the filesystem when...", // Optional custom system prompt override
      customToolDescriptions: {
        ls: "Use the ls tool when...",
        read_file: "Use the read_file tool to...",
      }, // Optional: Custom descriptions for filesystem tools
    }),
  ],
});
```


当您为 `/memories/` 配置带有 `StoreBackend` 的 `CompositeBackend` 时，任何以 **/memories/** 为前缀的文件都会保存到持久化存储中，并在不同线程之间存活。没有此前缀的文件保留在临时状态存储中。

## 子代理中间件

将任务移交给子代理可以隔离上下文，保持主（监督）代理的上下文窗口干净，同时仍然深入处理任务。

子代理中间件允许您通过 `task` 工具提供子代理。



```typescript
import { tool } from "langchain";
import { createAgent } from "langchain";
import { createSubAgentMiddleware } from "deepagents";
import { z } from "zod";

const getWeather = tool(
  async ({ city }: { city: string }) => {
    return `The weather in ${city} is sunny.`;
  },
  {
    name: "get_weather",
    description: "Get the weather in a city.",
    schema: z.object({
      city: z.string(),
    }),
  },
);

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  middleware: [
    createSubAgentMiddleware({
      defaultModel: "claude-sonnet-4-5-20250929",
      defaultTools: [],
      subagents: [
        {
          name: "weather",
          description: "This subagent can get weather in cities.",
          systemPrompt: "Use the get_weather tool to get the weather in a city.",
          tools: [getWeather],
          model: "gpt-4o",
          middleware: [],
        },
      ],
    }),
  ],
});
```


子代理使用**名称**、**描述**、**系统提示**和**工具**定义。您还可以为子代理提供自定义**模型**或额外的**中间件**。当您想为子代理提供额外的状态键以与主代理共享时，这特别有用。

对于更复杂的用例，您还可以提供自己的预构建 LangGraph 图作为子代理。



```typescript
import { tool, createAgent } from "langchain";
import { createSubAgentMiddleware, type SubAgent } from "deepagents";
import { z } from "zod";

const getWeather = tool(
  async ({ city }: { city: string }) => {
    return `The weather in ${city} is sunny.`;
  },
  {
    name: "get_weather",
    description: "Get the weather in a city.",
    schema: z.object({
      city: z.string(),
    }),
  },
);

const weatherSubagent: SubAgent = {
  name: "weather",
  description: "This subagent can get weather in cities.",
  systemPrompt: "Use the get_weather tool to get the weather in a city.",
  tools: [getWeather],
  model: "gpt-4o",
  middleware: [],
};

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  middleware: [
    createSubAgentMiddleware({
      defaultModel: "claude-sonnet-4-5-20250929",
      defaultTools: [],
      subagents: [weatherSubagent],
    }),
  ],
});
```


除了任何用户定义的子代理外，主代理始终可以访问 `general-purpose` 子代理。此子代理具有与主代理相同的指令和所有可访问的工具。`general-purpose` 子代理的主要目的是上下文隔离——主代理可以将复杂任务委托给此子代理，并获得简洁的答案，而不会因中间工具调用而膨胀。

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\deepagents\middleware.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
