---
title: 长期记忆
---



## 概述

LangChain 代理使用 [LangGraph 持久化](/oss/javascript/langgraph/persistence#memory-store)来实现长期记忆。这是一个更高级的主题，需要了解 LangGraph 才能使用。


## 记忆存储

LangGraph 将长期记忆作为 JSON 文档存储在[存储](/oss/javascript/langgraph/persistence#memory-store)中。

每个记忆都组织在自定义 `namespace`（类似于文件夹）和不同的 `key`（如文件名）下。命名空间通常包括用户或组织 ID 或其他标签，使组织信息更容易。

这种结构支持记忆的分层组织。然后通过内容过滤器支持跨命名空间搜索。



```typescript
import { InMemoryStore } from "@langchain/langgraph";

const embed = (texts: string[]): number[][] => {
    // Replace with an actual embedding function or LangChain embeddings object
    return texts.map(() => [1.0, 2.0]);
};

// InMemoryStore 将数据保存到内存字典中。在生产环境中使用基于数据库的存储。
const store = new InMemoryStore({ index: { embed, dims: 2 } }); // [!code highlight]
const userId = "my-user";
const applicationContext = "chitchat";
const namespace = [userId, applicationContext]; // [!code highlight]

await store.put( // [!code highlight]
    namespace,
    "a-memory",
    {
        rules: [
            "User likes short, direct language",
            "User only speaks English & TypeScript",
        ],
        "my-key": "my-value",
    }
);

// 通过 ID 获取"记忆"
const item = await store.get(namespace, "a-memory"); // [!code highlight]

// 在此命名空间内搜索"记忆"，按内容等价性过滤，按向量相似度排序
const items = await store.search( // [!code highlight]
    namespace,
    {
        filter: { "my-key": "my-value" },
        query: "language preferences"
    }
);
```


有关记忆存储的更多信息，请参阅[持久化](/oss/javascript/langgraph/persistence#memory-store)指南。

## 在工具中读取长期记忆



```typescript A tool the agent can use to look up user information
import * as z from "zod";
import { createAgent, tool } from "langchain";
import { InMemoryStore, type Runtime } from "@langchain/langgraph";

// InMemoryStore 将数据保存到内存字典中。在生产环境中使用基于数据库的存储。
const store = new InMemoryStore(); // [!code highlight]
const contextSchema = z.object({
    userId: z.string(),
});

// 使用 put 方法将示例数据写入存储
await store.put( // [!code highlight]
    ["users"], // 命名空间，用于将相关数据分组（用户数据的用户命名空间）
    "user_123", // 命名空间内的键（用户 ID 作为键）
    {
        name: "John Smith",
        language: "English",
    } // 为给定用户存储的数据
);

const getUserInfo = tool(
  // 查找用户信息。
  async (_, runtime: Runtime<z.infer<typeof contextSchema>>) => {
    // 访问存储 - 与提供给 `createAgent` 的相同
    const userId = runtime.context?.userId;
    if (!userId) {
      throw new Error("userId is required");
    }
    // 从存储中检索数据 - 返回包含值和元数据的 StoreValue 对象
    const userInfo = await runtime.store.get(["users"], userId);
    return userInfo?.value ? JSON.stringify(userInfo.value) : "Unknown user";
  },
  {
    name: "getUserInfo",
    description: "从存储中通过 userId 查找用户信息。",
    schema: z.object({}),
  }
);

const agent = createAgent({
    model: "gpt-4o-mini",
    tools: [getUserInfo],
    contextSchema,
    // 将存储传递给代理 - 使代理在运行工具时能够访问存储
    store, // [!code highlight]
});

// 运行代理
const result = await agent.invoke(
    { messages: [{ role: "user", content: "look up user information" }] },
    { context: { userId: "user_123" } } // [!code highlight]
);

console.log(result.messages.at(-1)?.content);
/**
 * Outputs:
 * User Information:
 * - Name: John Smith
 * - Language: English
 */
```



<a id="write-long-term"></a>
## 从工具写入长期记忆



```typescript 更新用户信息的工具示例
import * as z from "zod";
import { tool, createAgent, type AgentRuntime } from "langchain";
import { InMemoryStore, type Runtime } from "@langchain/langgraph";

// InMemoryStore 将数据保存到内存字典中。在生产环境中使用基于数据库的存储。
const store = new InMemoryStore(); // [!code highlight]

const contextSchema = z.object({
    userId: z.string(),
});

// 模式为 LLM 定义用户信息的结构
const UserInfo = z.object({
    name: z.string(),
});

// 允许代理更新用户信息的工具（对聊天应用很有用）
const saveUserInfo = tool(
  async (userInfo: z.infer<typeof UserInfo>, runtime: Runtime<z.infer<typeof contextSchema>>) => {
    const userId = runtime.context?.userId;
    if (!userId) {
      throw new Error("userId is required");
    }
    // 将数据存储在存储中（命名空间、键、数据）
    await runtime.store.put(["users"], userId, userInfo);
    return "Successfully saved user info.";
  },
  {
    name: "save_user_info",
    description: "保存用户信息",
    schema: UserInfo,
  }
);

const agent = createAgent({
    model: "gpt-4o-mini",
    tools: [saveUserInfo],
    contextSchema,
    store, // [!code highlight]
});

// 运行代理
await agent.invoke(
    { messages: [{ role: "user", content: "My name is John Smith" }] },
    // 在上下文中传递 userId 以标识正在更新谁的信息
    { context: { userId: "user_123" } } // [!code highlight]
);

// 您可以直接访问存储以获取值
const result = await store.get(["users"], "user_123");
console.log(result?.value); // Output: { name: "John Smith" }
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langchain\long-term-memory.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
