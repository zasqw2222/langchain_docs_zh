---
title: 自定义中间件
---

通过在代理执行流程中的特定点实现钩子来构建自定义中间件。

## 钩子

中间件提供两种风格的钩子来拦截代理执行：

<CardGroup cols={2}>
  <Card title="节点式钩子" icon="share-nodes" href="#node-style-hooks">
    在特定执行点顺序运行。
  </Card>
  <Card title="包装式钩子" icon="container-storage" href="#wrap-style-hooks">
    围绕每个模型或工具调用运行。
  </Card>
</CardGroup>

### 节点式钩子

在特定执行点顺序运行。用于日志记录、验证和状态更新。

**可用钩子：**



- `beforeAgent` - 在代理启动之前（每次调用一次）
- `beforeModel` - 在每次模型调用之前
- `afterModel` - 在每次模型响应之后
- `afterAgent` - 在代理完成之后（每次调用一次）


**Example:**



```typescript
import { createMiddleware, AIMessage } from "langchain";

const createMessageLimitMiddleware = (maxMessages: number = 50) => {
  return createMiddleware({
    name: "MessageLimitMiddleware",
    beforeModel: (state) => {
      if (state.messages.length === maxMessages) {
        return {
          messages: [new AIMessage("Conversation limit reached.")],
          jumpTo: "end",
        };
      }
      return;
    },
    afterModel: (state) => {
      const lastMessage = state.messages[state.messages.length - 1];
      console.log(`Model returned: ${lastMessage.content}`);
      return;
    },
  });
};
```



### 包装式钩子

拦截执行并控制何时调用处理程序。用于重试、缓存和转换。

您决定处理程序是否被调用零次（短路）、一次（正常流程）或多次（重试逻辑）。

**可用钩子：**



- `wrapModelCall` - 围绕每个模型调用
- `wrapToolCall` - 围绕每个工具调用


**Example:**



```typescript
import { createMiddleware } from "langchain";

const createRetryMiddleware = (maxRetries: number = 3) => {
  return createMiddleware({
    name: "RetryMiddleware",
    wrapModelCall: (request, handler) => {
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          return handler(request);
        } catch (e) {
          if (attempt === maxRetries - 1) {
            throw e;
          }
          console.log(`Retry ${attempt + 1}/${maxRetries} after error: ${e}`);
        }
      }
      throw new Error("Unreachable");
    },
  });
};
```



## 创建中间件



使用 `createMiddleware` 函数定义自定义中间件：

```typescript
import { createMiddleware } from "langchain";

const loggingMiddleware = createMiddleware({
  name: "LoggingMiddleware",
  beforeModel: (state) => {
    console.log(`About to call model with ${state.messages.length} messages`);
    return;
  },
  afterModel: (state) => {
    const lastMessage = state.messages[state.messages.length - 1];
    console.log(`Model returned: ${lastMessage.content}`);
    return;
  },
});
```



## 自定义状态模式

中间件可以使用自定义属性扩展代理的状态。



```typescript
import { createMiddleware, createAgent, HumanMessage } from "langchain";
import * as z from "zod";

const callCounterMiddleware = createMiddleware({
  name: "CallCounterMiddleware",
  stateSchema: z.object({
    modelCallCount: z.number().default(0),
    userId: z.string().optional(),
  }),
  beforeModel: (state) => {
    if (state.modelCallCount > 10) {
      return { jumpTo: "end" };
    }
    return;
  },
  afterModel: (state) => {
    return { modelCallCount: state.modelCallCount + 1 };
  },
});

const agent = createAgent({
  model: "gpt-4o",
  tools: [...],
  middleware: [callCounterMiddleware],
});

const result = await agent.invoke({
  messages: [new HumanMessage("Hello")],
  modelCallCount: 0,
  userId: "user-123",
});
```



## 执行顺序

使用多个中间件时，了解它们如何执行：



```typescript
const agent = createAgent({
  model: "gpt-4o",
  middleware: [middleware1, middleware2, middleware3],
  tools: [...],
});
```


<Accordion title="执行流程">

**Before 钩子按顺序运行：**
1. `middleware1.before_agent()`
2. `middleware2.before_agent()`
3. `middleware3.before_agent()`

__代理循环开始__

4. `middleware1.before_model()`
5. `middleware2.before_model()`
6. `middleware3.before_model()`

**Wrap 钩子像函数调用一样嵌套：**

7. `middleware1.wrap_model_call()` → `middleware2.wrap_model_call()` → `middleware3.wrap_model_call()` → model

**After 钩子按相反顺序运行：**

8. `middleware3.after_model()`
9. `middleware2.after_model()`
10. `middleware1.after_model()`

__代理循环结束__

11. `middleware3.after_agent()`
12. `middleware2.after_agent()`
13. `middleware1.after_agent()`

</Accordion>

**关键规则：**
- `before_*` 钩子：从第一个到最后一个
- `after_*` 钩子：从最后一个到第一个（相反）
- `wrap_*` 钩子：嵌套（第一个中间件包装所有其他）

## 代理跳转

要从中间件提前退出，返回带有 `jump_to` 的字典：

**可用跳转目标：**
- `'end'`: 跳转到代理执行的末尾（或第一个 `after_agent` 钩子）
- `'tools'`: 跳转到工具节点
- `'model'`: 跳转到模型节点（或第一个 `before_model` 钩子）



```typescript
import { createMiddleware, AIMessage } from "langchain";

const blockedContentMiddleware = createMiddleware({
  name: "BlockedContentMiddleware",
  afterModel: (state) => {
    const lastMessage = state.messages[state.messages.length - 1];
    if (lastMessage.content.includes("BLOCKED")) {
      return {
        messages: [new AIMessage("I cannot respond to that request.")],
        jumpTo: "end",
      };
    }
    return;
  },
});
```



## 最佳实践

1. 保持中间件专注 - 每个应该做好一件事
2. 优雅地处理错误 - 不要让中间件错误使代理崩溃
3. **使用适当的钩子类型**：
    - 节点式用于顺序逻辑（日志记录、验证）
    - 包装式用于控制流（重试、回退、缓存）
4. 清楚地记录任何自定义状态属性
5. 在集成之前独立地对中间件进行单元测试
6. 考虑执行顺序 - 将关键中间件放在列表的第一位
7. 尽可能使用内置中间件

## 示例

### 动态模型选择



```typescript
import { createMiddleware, initChatModel } from "langchain";

const dynamicModelMiddleware = createMiddleware({
  name: "DynamicModelMiddleware",
  wrapModelCall: (request, handler) => {
    const modifiedRequest = { ...request };
    if (request.messages.length > 10) {
      modifiedRequest.model = initChatModel("gpt-4o");
    } else {
      modifiedRequest.model = initChatModel("gpt-4o-mini");
    }
    return handler(modifiedRequest);
  },
});
```



### 工具调用监控



```typescript
import { createMiddleware } from "langchain";

const toolMonitoringMiddleware = createMiddleware({
  name: "ToolMonitoringMiddleware",
  wrapToolCall: (request, handler) => {
    console.log(`Executing tool: ${request.toolCall.name}`);
    console.log(`Arguments: ${JSON.stringify(request.toolCall.args)}`);
    try {
      const result = handler(request);
      console.log("Tool completed successfully");
      return result;
    } catch (e) {
      console.log(`Tool failed: ${e}`);
      throw e;
    }
  },
});
```



### 动态选择工具

在运行时选择相关工具以提高性能和准确性。

**好处：**
- **更短的提示** - 通过仅暴露相关工具来降低复杂性
- **更好的准确性** - 模型从更少的选项中选择正确
- **权限控制** - 根据用户访问权限动态过滤工具



```typescript
import { createAgent, createMiddleware } from "langchain";

const toolSelectorMiddleware = createMiddleware({
  name: "ToolSelector",
  wrapModelCall: (request, handler) => {
    // Select a small, relevant subset of tools based on state/context
    const relevantTools = selectRelevantTools(request.state, request.runtime);
    const modifiedRequest = { ...request, tools: relevantTools };
    return handler(modifiedRequest);
  },
});

const agent = createAgent({
  model: "gpt-4o",
  tools: allTools,
  middleware: [toolSelectorMiddleware],
});
```



## 其他资源

- [中间件 API 参考](https://reference.langchain.com/python/langchain/middleware/)
- [内置中间件](/oss/javascript/langchain/middleware/built-in)
- [测试代理](/oss/javascript/langchain/test)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langchain\middleware\custom.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
