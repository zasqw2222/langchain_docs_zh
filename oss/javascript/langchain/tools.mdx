---
title: 工具
---



许多 AI 应用通过自然语言与用户交互。但是，某些用例要求模型使用结构化输入直接与外部系统（如 API、数据库或文件系统）交互。

工具是[代理](/oss/javascript/langchain/agents)调用以执行操作的组件。它们通过让模型通过明确定义的输入和输出与世界交互来扩展模型能力。工具封装了一个可调用函数及其输入模式。这些可以传递给兼容的[聊天模型](/oss/javascript/langchain/models)，允许模型决定是否调用工具以及使用什么参数。在这些场景中，工具调用使模型能够生成符合指定输入模式的请求。

<Note>
**服务器端工具使用**

某些聊天模型（例如 [OpenAI](/oss/javascript/integrations/chat/openai)、[Anthropic](/oss/javascript/integrations/chat/anthropic) 和 [Gemini](/oss/javascript/integrations/chat/google_generative_ai)）具有[内置工具](/oss/javascript/langchain/models#server-side-tool-use)，这些工具在服务器端执行，例如网络搜索和代码解释器。请参阅[提供者概述](/oss/javascript/integrations/providers/overview)以了解如何使用您的特定聊天模型访问这些工具。
</Note>

## 创建工具

### 基本工具定义



创建工具的最简单方法是从 `langchain` 包导入 `tool` 函数。您可以使用 [zod](https://zod.dev/) 定义工具的输入模式：

```ts
import * as z from "zod"
import { tool } from "langchain"

const searchDatabase = tool(
  ({ query, limit }) => `Found ${limit} results for '${query}'`,
  {
    name: "search_database",
    description: "Search the customer database for records matching the query.",
    schema: z.object({
      query: z.string().describe("Search terms to look for"),
      limit: z.number().describe("Maximum number of results to return"),
    }),
  }
);
```




## 访问上下文

<Info>
**为什么这很重要：**当工具可以访问代理状态、运行时上下文和长期记忆时，它们最强大。这使工具能够做出上下文感知的决策、个性化响应并在对话之间维护信息。



运行时上下文提供了一种结构化方式来向工具提供运行时数据，例如数据库连接、用户 ID 或配置。这避免了全局状态，并使工具保持可测试和可重用。

</Info>



#### 上下文



工具可以通过 `config` 参数访问代理的运行时上下文：

```ts
import * as z from "zod"
import { ChatOpenAI } from "@langchain/openai"
import { createAgent } from "langchain"

const getUserName = tool(
  (_, config) => {
    return config.context.user_name
  },
  {
    name: "get_user_name",
    description: "Get the user's name.",
    schema: z.object({}),
  }
);

const contextSchema = z.object({
  user_name: z.string(),
});

const agent = createAgent({
  model: new ChatOpenAI({ model: "gpt-4o" }),
  tools: [getUserName],
  contextSchema,
});

const result = await agent.invoke(
  {
    messages: [{ role: "user", content: "What is my name?" }]
  },
  {
    context: { user_name: "John Smith" }
  }
);
```


#### 记忆（存储）



使用存储访问跨对话的持久数据。存储通过 `config.store` 访问，允许您保存和检索特定于用户或特定于应用程序的数据。

```ts expandable
import * as z from "zod";
import { createAgent, tool } from "langchain";
import { InMemoryStore } from "@langchain/langgraph";
import { ChatOpenAI } from "@langchain/openai";

const store = new InMemoryStore();

// 访问记忆
const getUserInfo = tool(
  async ({ user_id }) => {
    const value = await store.get(["users"], user_id);
    console.log("get_user_info", user_id, value);
    return value;
  },
  {
    name: "get_user_info",
    description: "Look up user info.",
    schema: z.object({
      user_id: z.string(),
    }),
  }
);

// 更新记忆
const saveUserInfo = tool(
  async ({ user_id, name, age, email }) => {
    console.log("save_user_info", user_id, name, age, email);
    await store.put(["users"], user_id, { name, age, email });
    return "Successfully saved user info.";
  },
  {
    name: "save_user_info",
    description: "Save user info.",
    schema: z.object({
      user_id: z.string(),
      name: z.string(),
      age: z.number(),
      email: z.string(),
    }),
  }
);

const agent = createAgent({
  model: new ChatOpenAI({ model: "gpt-4o" }),
  tools: [getUserInfo, saveUserInfo],
  store,
});

// 第一次会话：保存用户信息
await agent.invoke({
  messages: [
    {
      role: "user",
      content: "Save the following user: userid: abc123, name: Foo, age: 25, email: foo@langchain.dev",
    },
  ],
});

// 第二次会话：获取用户信息
const result = await agent.invoke({
  messages: [
    { role: "user", content: "Get user info for user with id 'abc123'" },
  ],
});

console.log(result);
// Here is the user info for user with ID "abc123":
// - Name: Foo
// - Age: 25
// - Email: foo@langchain.dev
```


#### 流式写入器



使用 `config.streamWriter` 在工具执行时流式传输自定义更新。这对于向用户提供有关工具正在执行的操作的实时反馈很有用。

```ts
import * as z from "zod";
import { tool } from "langchain";

const getWeather = tool(
  ({ city }, config) => {
    const writer = config.streamWriter;

    // 在工具执行时流式传输自定义更新
    writer(`Looking up data for city: ${city}`);
    writer(`Acquired data for city: ${city}`);

    return `It's always sunny in ${city}!`;
  },
  {
    name: "get_weather",
    description: "Get weather for a given city.",
    schema: z.object({
      city: z.string(),
    }),
  }
);
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langchain\tools.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
