---
title: 上下文概述
sidebarTitle: 上下文
---

**上下文工程**是构建动态系统的实践,以正确的格式提供正确的信息和工具,以便 AI 应用程序能够完成任务。上下文可以沿着两个关键维度进行表征:

1. 按**可变性**:
  * **静态上下文**:在执行期间不会改变的不可变数据(例如,用户元数据、数据库连接、工具)
  * **动态上下文**:随着应用程序运行而演变的可变数据(例如,对话历史、中间结果、工具调用观察)
2. 按**生命周期**:
  * **运行时上下文**:范围限定于单次运行或调用的数据
  * **跨对话上下文**:跨多个对话或会话持久化的数据

<Tip>
    运行时上下文指的是本地上下文:您的代码运行所需的数据和依赖项。它**不**指:

    * LLM 上下文,即传递到 LLM 提示中的数据。
    * "上下文窗口",即可以传递给 LLM 的最大令牌数。



    运行时上下文是您在智能体中传递数据的方式。与其将内容存储在全局状态中,您可以将值(如数据库连接、用户会话或配置)附加到上下文并在工具和中间件中访问它们。这使事物保持无状态、可测试和可重用。例如,您可以使用运行时上下文中的用户元数据来获取用户偏好并将其馈送到上下文窗口中。


</Tip>

LangGraph 提供三种管理上下文的方法,结合了可变性和生命周期维度:



| 上下文类型                                                                                | 描述                                   | 可变性 | 生命周期           |
| ------------------------------------------------------------------------------------------- | --------------------------------------------- | ---------- | ------------------ |
| [**Config**](#config-static-context)                                                        | 在运行开始时传递的数据             | 静态     | 单次运行         |
| [**动态运行时上下文(状态)**](#dynamic-runtime-context-state)                       | 在单次运行期间演变的可变数据 | 动态    | 单次运行         |
| [**动态跨对话上下文(存储)**](#dynamic-cross-conversation-context-store) | 跨对话共享的持久数据   | 动态    | 跨对话 |

<a id="static-context"></a>
## Config

Config 用于不可变数据,如用户元数据或 API 密钥。当您有在运行中不会改变的值时使用此方法。

使用名为 **"configurable"** 的键指定配置,该键为此目的保留。

```typescript
await graph.invoke(
  { messages: [{ role: "user", content: "hi!" }] },
  { configurable: { user_id: "user_123" } } // [!code highlight]
);
```


<a id="state"></a>
## 动态运行时上下文

**动态运行时上下文**表示可以在单次运行期间演变的可变数据,并通过 LangGraph 状态对象进行管理。这包括对话历史、中间结果以及从工具或 LLM 输出派生的值。在 LangGraph 中,状态对象在运行期间充当[短期内存](/oss/javascript/concepts/memory)。

<Tabs>
    <Tab title="In an agent">
    示例展示了如何将状态合并到智能体**提示**中。

    状态也可以被智能体的**工具**访问,工具可以根据需要读取或更新状态。详见[工具调用指南](/oss/javascript/langchain/tools#short-term-memory)。



    ```typescript
    import { createAgent, createMiddleware } from "langchain";
    import type { AgentState } from "langchain";
    import * as z from "zod";

    const CustomState = z.object({ // [!code highlight]
      userName: z.string(),
    });

    const personalizedPrompt = createMiddleware({ // [!code highlight]
      name: "PersonalizedPrompt",
      stateSchema: CustomState,
      wrapModelCall: (request, handler) => {
        const userName = request.state.userName || "User";
        const systemPrompt = `You are a helpful assistant. User's name is ${userName}`;
        return handler({ ...request, systemPrompt });
      },
    });

    const agent = createAgent({  // [!code highlight]
      model: "claude-sonnet-4-5-20250929",
      tools: [/* your tools here */],
      middleware: [personalizedPrompt] as const, // [!code highlight]
    });

    await agent.invoke({
      messages: [{ role: "user", content: "hi!" }],
      userName: "John Smith",
    });
    ```

    </Tab>
    <Tab title="In a workflow">


    ```typescript
    import type { BaseMessage } from "@langchain/core/messages";
    import { StateGraph, MessagesZodMeta, START } from "@langchain/langgraph";
    import { registry } from "@langchain/langgraph/zod";
    import * as z from "zod";

    const CustomState = z.object({  // [!code highlight]
      messages: z
        .array(z.custom<BaseMessage>())
        .register(registry, MessagesZodMeta),
      extraField: z.number(),
    });

    const builder = new StateGraph(CustomState)
      .addNode("node", async (state) => {  // [!code highlight]
        const messages = state.messages;
        // ...
        return {  // [!code highlight]
          extraField: state.extraField + 1,
        };
      })
      .addEdge(START, "node");

    const graph = builder.compile();
    ```

    </Tab>
</Tabs>

<Tip>
    **启用内存**
    请参阅[内存指南](/oss/javascript/langgraph/add-memory)了解有关如何启用内存的更多详细信息。这是一个强大的功能,允许您在多次调用中持久化智能体的状态。否则,状态仅限于单次运行。
</Tip>

<a id="store"></a>

## 动态跨对话上下文

**动态跨对话上下文**表示跨多个对话或会话的持久可变数据,并通过 LangGraph 存储进行管理。这包括用户配置文件、偏好和历史交互。LangGraph 存储充当跨多次运行的[长期内存](/oss/javascript/concepts/memory#long-term-memory)。这可用于读取或更新持久事实(例如,用户配置文件、偏好、先前的交互)。

## 另请参阅

- [内存概念概述](/oss/javascript/concepts/memory)
- [LangChain 中的短期内存](/oss/javascript/langchain/short-term-memory)
- [LangChain 中的长期内存](/oss/javascript/langchain/long-term-memory)
- [LangGraph 中的内存](/oss/javascript/langgraph/add-memory)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\concepts\context.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
