---
title: 使用 Graph API
sidebarTitle: 使用 Graph API
---



import ChatModelTabs from '/snippets/chat-model-tabs.mdx';

本指南演示了 LangGraph Graph API 的基础知识。它介绍了[状态](#define-and-update-state)，以及如何组合常见的图结构，如[序列](#create-a-sequence-of-steps)、[分支](#create-branches)和[循环](#create-and-control-loops)。它还涵盖了 LangGraph 的控制功能，包括用于 map-reduce 工作流的 [Send API](#map-reduce-and-the-send-api) 和用于将状态更新与节点间的"跳转"相结合的 [Command API](#combine-control-flow-and-state-updates-with-command)。

## 设置



安装 `langgraph`：

```bash
npm install @langchain/langgraph
```


<Tip>
**设置 LangSmith 以获得更好的调试体验**

注册 [LangSmith](https://smith.langchain.com) 以快速发现问题并提高 LangGraph 项目的性能。LangSmith 让您可以使用跟踪数据来调试、测试和监控使用 LangGraph 构建的 LLM 应用程序——在[文档](/langsmith/observability)中了解更多关于如何开始的信息。
</Tip>

## 定义和更新状态

这里我们展示如何在 LangGraph 中定义和更新[状态](/oss/javascript/langgraph/graph-api#state)。我们将演示：

1. 如何使用状态定义图的[模式](/oss/javascript/langgraph/graph-api#schema)
2. 如何使用[reducers](/oss/javascript/langgraph/graph-api#reducers) 来控制状态更新的处理方式。

### 定义状态



LangGraph 中的[状态](/oss/javascript/langgraph/graph-api#state)可以使用 Zod 模式定义。下面我们将使用 Zod。有关使用替代方法的详细信息，请参阅[此部分](#alternative-state-definitions)。


默认情况下，图将具有相同的输入和输出模式，状态决定该模式。有关如何定义不同的输入和输出模式，请参阅[此部分](#define-input-and-output-schemas)。

让我们考虑一个使用[消息](/oss/javascript/langgraph/graph-api#messagesstate)的简单示例。这代表了许多 LLM 应用程序的通用状态形式。有关更多详细信息，请参阅我们的[概念页面](/oss/javascript/langgraph/graph-api#working-with-messages-in-graph-state)。



```typescript
import { BaseMessage } from "@langchain/core/messages";
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```

此状态跟踪[消息](https://js.langchain.com/docs/concepts/messages/)对象列表，以及一个额外的整数字段。


### 更新状态



让我们构建一个包含单个节点的示例图。我们的[节点](/oss/javascript/langgraph/graph-api#nodes)只是一个读取图状态并对其进行更新的 TypeScript 函数。此函数的第一个参数始终是状态：

```typescript
import { AIMessage } from "@langchain/core/messages";

const node = (state: z.infer<typeof State>) => {
  const messages = state.messages;
  const newMessage = new AIMessage("Hello!");
  return { messages: messages.concat([newMessage]), extraField: 10 };
};
```

此节点简单地将消息追加到我们的消息列表，并填充一个额外字段。


<Warning>
节点应该直接返回对状态的更新，而不是改变状态。
</Warning>



接下来让我们定义一个包含此节点的简单图。我们使用 [`StateGraph`](/oss/javascript/langgraph/graph-api#stategraph) 来定义一个在此状态上操作的图。然后我们使用 [`addNode`](/oss/javascript/langgraph/graph-api#nodes) 填充我们的图。

```typescript
import { StateGraph } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge("__start__", "node")
  .compile();
```


LangGraph 提供了内置的工具来可视化您的图。让我们检查我们的图。有关可视化的详细信息，请参阅[此部分](#visualize-your-graph)。



```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


在这种情况下，我们的图只执行单个节点。让我们进行一个简单的调用：



```typescript
import { HumanMessage } from "@langchain/core/messages";

const result = await graph.invoke({ messages: [new HumanMessage("Hi")], extraField: 0 });
console.log(result);
```

```
{ messages: [HumanMessage { content: 'Hi' }, AIMessage { content: 'Hello!' }], extraField: 10 }
```


请注意：

* 我们通过更新状态的单个键来启动调用。
* 我们在调用结果中接收整个状态。



为了方便起见，我们经常通过日志记录检查[消息对象](https://js.langchain.com/docs/concepts/messages/)的内容：

```typescript
for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```


### 使用 reducers 处理状态更新

状态中的每个键都可以有自己的独立[reducer](/oss/javascript/langgraph/graph-api#reducers) 函数，它控制如何应用来自节点的更新。如果没有明确指定 reducer 函数，则假定对该键的所有更新都应该覆盖它。



对于 Zod 状态模式，我们可以通过在模式字段上使用特殊的 `.langgraph.reducer()` 方法来定义 reducers。

在之前的示例中，我们的节点通过将消息追加到它来更新状态中的 `"messages"` 键。下面，我们为此键添加一个 reducer，以便自动追加更新：

```typescript
import "@langchain/langgraph/zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).langgraph.reducer((x, y) => x.concat(y)),  // [!code highlight]
  extraField: z.number(),
});
```

现在我们的节点可以简化：

```typescript
const node = (state: z.infer<typeof State>) => {
  const newMessage = new AIMessage("Hello!");
  return { messages: [newMessage], extraField: 10 };  // [!code highlight]
};
```




```typescript
import { START } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge(START, "node")
  .compile();

const result = await graph.invoke({ messages: [new HumanMessage("Hi")] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```


#### MessagesState

在实践中，更新消息列表还有其他考虑因素：

* 我们可能希望更新状态中的现有消息。
* 我们可能希望接受[消息格式](/oss/javascript/langgraph/graph-api#using-messages-in-your-graph)的简写形式，例如 [OpenAI 格式](https://python.langchain.com/docs/concepts/messages/#openai-format)。



LangGraph 包含一个内置的 `MessagesZodMeta`，它处理这些考虑因素：

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({  // [!code highlight]
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});

const graph = new StateGraph(State)
  .addNode("node", (state) => {
    const newMessage = new AIMessage("Hello!");
    return { messages: [newMessage], extraField: 10 };
  })
  .addEdge(START, "node")
  .compile();
```

```typescript
const inputMessage = { role: "user", content: "Hi" };  // [!code highlight]

const result = await graph.invoke({ messages: [inputMessage] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```

这是涉及[聊天模型](https://js.langchain.com/docs/concepts/chat_models/)的应用程序的通用状态表示。LangGraph 包含这个预构建的 `MessagesZodMeta` 以便于使用，因此我们可以有：

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```




### 定义输入和输出模式

默认情况下，`StateGraph` 使用单个模式运行，所有节点都期望使用该模式进行通信。但是，也可以为图定义不同的输入和输出模式。

当指定不同的模式时，仍将使用内部模式进行节点之间的通信。输入模式确保提供的输入匹配预期结构，而输出模式根据定义的输出模式过滤内部数据，仅返回相关信息。

下面，我们将看到如何定义不同的输入和输出模式。



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// 定义输入的模式
const InputState = z.object({
  question: z.string(),
});

// 定义输出的模式
const OutputState = z.object({
  answer: z.string(),
});

// 定义整体模式，结合输入和输出
const OverallState = InputState.merge(OutputState);

// 使用指定的输入和输出模式构建图
const graph = new StateGraph({
  input: InputState,
  output: OutputState,
  state: OverallState,
})
  .addNode("answerNode", (state) => {
    // 示例答案和一个额外键
    return { answer: "bye", question: state.question };
  })
  .addEdge(START, "answerNode")
  .addEdge("answerNode", END)
  .compile();

// 使用输入调用图并打印结果
console.log(await graph.invoke({ question: "hi" }));
```

```
{ answer: 'bye' }
```


请注意，invoke 的输出只包括输出模式。

### 在节点之间传递私有状态

在某些情况下，您可能希望节点交换对中间逻辑至关重要但不需要成为图主模式一部分的信息。此私有数据与图的整体输入/输出无关，应仅在特定节点之间共享。

下面，我们将创建一个由三个节点（node_1、node_2 和 node_3）组成的示例顺序图，其中私有数据在前两个步骤（node_1 和 node_2）之间传递，而第三步（node_3）只能访问公共的整体状态。



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// 图的整体状态（这是在节点之间共享的公共状态）
const OverallState = z.object({
  a: z.string(),
});

// node1 的输出包含不属于整体状态的私有数据
const Node1Output = z.object({
  privateData: z.string(),
});

// 私有数据仅在 node1 和 node2 之间共享
const node1 = (state: z.infer<typeof OverallState>): z.infer<typeof Node1Output> => {
  const output = { privateData: "set by node1" };
  console.log(`Entered node 'node1':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// 节点 2 的输入只请求 node1 之后可用的私有数据
const Node2Input = z.object({
  privateData: z.string(),
});

const node2 = (state: z.infer<typeof Node2Input>): z.infer<typeof OverallState> => {
  const output = { a: "set by node2" };
  console.log(`Entered node 'node2':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// 节点 3 只能访问整体状态（无法访问 node1 的私有数据）
const node3 = (state: z.infer<typeof OverallState>): z.infer<typeof OverallState> => {
  const output = { a: "set by node3" };
  console.log(`Entered node 'node3':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// 按顺序连接节点
// node2 接受来自 node1 的私有数据，而
// node3 看不到私有数据。
const graph = new StateGraph({
  state: OverallState,
  nodes: {
    node1: { action: node1, output: Node1Output },
    node2: { action: node2, input: Node2Input },
    node3: { action: node3 },
  }
})
  .addEdge(START, "node1")
  .addEdge("node1", "node2")
  .addEdge("node2", "node3")
  .addEdge("node3", END)
  .compile();

// 使用初始状态调用图
const response = await graph.invoke({ a: "set at start" });

console.log(`\nOutput of graph invocation: ${JSON.stringify(response)}`);
```

```
Entered node 'node1':
    ut: {"a":"set at start"}.
    urned: {"privateData":"set by node1"}
Entered node 'node2':
    ut: {"privateData":"set by node1"}.
    urned: {"a":"set by node2"}
Entered node 'node3':
    ut: {"a":"set by node2"}.
    urned: {"a":"set by node3"}

Output of graph invocation: {"a":"set by node3"}
```




### 替代状态定义

虽然 Zod 模式是推荐的方法，但 LangGraph 也支持其他定义状态模式的方式：

```typescript
import { BaseMessage } from "@langchain/core/messages";
import { StateGraph } from "@langchain/langgraph";

interface WorkflowChannelsState {
  messages: BaseMessage[];
  question: string;
  answer: string;
}

const workflowWithChannels = new StateGraph<WorkflowChannelsState>({
  channels: {
    messages: {
      reducer: (currentState, updateValue) => currentState.concat(updateValue),
      default: () => [],
    },
    question: null,
    answer: null,
  },
});
```


## 添加运行时配置

有时您希望在调用图时能够配置它。例如，您可能希望能够在运行时指定使用哪个 LLM 或系统提示，而_不会用这些参数污染图状态_。

要添加运行时配置：

1. 为您的配置指定一个模式
2. 将配置添加到节点或条件边的函数签名中
3. 将配置传递到图中。

请参阅下面的简单示例：



```typescript
import { StateGraph, END, START } from "@langchain/langgraph";
import * as z from "zod";

// 1. 指定配置模式
const ContextSchema = z.object({
  myRuntimeValue: z.string(),
});

// 2. 定义一个在节点中访问配置的图
const StateSchema = z.object({
  myStateValue: z.number(),
});

const graph = new StateGraph(StateSchema, ContextSchema)
  .addNode("node", (state, runtime) => {
    if (runtime?.context?.myRuntimeValue === "a") {  // [!code highlight]
      return { myStateValue: 1 };
    } else if (runtime?.context?.myRuntimeValue === "b") {  // [!code highlight]
      return { myStateValue: 2 };
    } else {
      throw new Error("Unknown values.");
    }
  })
  .addEdge(START, "node")
  .addEdge("node", END)
  .compile();

// 3. 在运行时传入配置：
console.log(await graph.invoke({}, { context: { myRuntimeValue: "a" } }));  // [!code highlight]
console.log(await graph.invoke({}, { context: { myRuntimeValue: "b" } }));  // [!code highlight]
```

```
{ myStateValue: 1 }
{ myStateValue: 2 }
```


<Accordion title="扩展示例：在运行时指定 LLM">


  下面我们演示一个实际示例，其中我们在运行时配置使用哪个 LLM。我们将使用 OpenAI 和 Anthropic 模型。

  ```typescript
  import { ChatOpenAI } from "@langchain/openai";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { BaseMessage } from "@langchain/core/messages";
  import { MessagesZodMeta, StateGraph, START, END } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import { RunnableConfig } from "@langchain/core/runnables";
  import * as z from "zod";

  const ConfigSchema = z.object({
    modelProvider: z.string().default("anthropic"),
  });

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  const MODELS = {
    anthropic: new ChatAnthropic({ model: "claude-haiku-4-5-20251001" }),
    openai: new ChatOpenAI({ model: "gpt-4o-mini" }),
  };

  const graph = new StateGraph(MessagesZodState, ConfigSchema)
    .addNode("model", async (state, config) => {
      const modelProvider = config?.configurable?.modelProvider || "anthropic";
      const model = MODELS[modelProvider as keyof typeof MODELS];
      const response = await model.invoke(state.messages);
      return { messages: [response] };
    })
    .addEdge(START, "model")
    .addEdge("model", END)
    .compile();

  // 用法
  const inputMessage = { role: "user", content: "hi" };
  // 没有配置时，使用默认值（Anthropic）
  const response1 = await graph.invoke({ messages: [inputMessage] });
  // 或者，可以设置 OpenAI
  const response2 = await graph.invoke(
    { messages: [inputMessage] },
    { configurable: { modelProvider: "openai" } },
  );

  console.log(response1.messages.at(-1)?.response_metadata?.model);
  console.log(response2.messages.at(-1)?.response_metadata?.model);
  ```

  ```
  claude-haiku-4-5-20251001
  gpt-4o-mini-2024-07-18
  ```

</Accordion>

<Accordion title="扩展示例：在运行时指定模型和系统消息">


  下面我们演示一个实际示例，其中我们配置两个参数：在运行时使用的 LLM 和系统消息。

  ```typescript
  import { ChatOpenAI } from "@langchain/openai";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { SystemMessage, BaseMessage } from "@langchain/core/messages";
  import { MessagesZodMeta, StateGraph, START, END } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import * as z from "zod";

  const ConfigSchema = z.object({
    modelProvider: z.string().default("anthropic"),
    systemMessage: z.string().optional(),
  });

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  const MODELS = {
    anthropic: new ChatAnthropic({ model: "claude-haiku-4-5-20251001" }),
    openai: new ChatOpenAI({ model: "gpt-4o-mini" }),
  };

  const graph = new StateGraph(MessagesZodState, ConfigSchema)
    .addNode("model", async (state, config) => {
      const modelProvider = config?.configurable?.modelProvider || "anthropic";
      const systemMessage = config?.configurable?.systemMessage;

      const model = MODELS[modelProvider as keyof typeof MODELS];
      let messages = state.messages;

      if (systemMessage) {
        messages = [new SystemMessage(systemMessage), ...messages];
      }

      const response = await model.invoke(messages);
      return { messages: [response] };
    })
    .addEdge(START, "model")
    .addEdge("model", END)
    .compile();

  // 用法
  const inputMessage = { role: "user", content: "hi" };
  const response = await graph.invoke(
    { messages: [inputMessage] },
    {
      configurable: {
        modelProvider: "openai",
        systemMessage: "Respond in Italian."
      }
    }
  );

  for (const message of response.messages) {
    console.log(`${message.getType()}: ${message.content}`);
  }
  ```

  ```
  human: hi
  ai: Ciao! Come posso aiutarti oggi?
  ```

</Accordion>

## 添加重试策略

在许多用例中，您可能希望节点具有自定义重试策略，例如，如果您正在调用 API、查询数据库或调用 LLM 等。LangGraph 允许您向节点添加重试策略。



要配置重试策略，请将 `retryPolicy` 参数传递给 [`addNode`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.Graph.html#addnode)。`retryPolicy` 参数接受一个 `RetryPolicy` 对象。下面我们使用默认参数实例化一个 `RetryPolicy` 对象并将其与节点关联：

```typescript
import { RetryPolicy } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("nodeName", nodeFunction, { retryPolicy: {} })
  .compile();
```

默认情况下，重试策略会重试任何异常，但以下情况除外：

* `TypeError`
* `SyntaxError`
* `ReferenceError`


<Accordion title="扩展示例：自定义重试策略">


  考虑一个从 SQL 数据库读取的示例。下面我们向节点传递两个不同的重试策略：

  ```typescript
  import Database from "better-sqlite3";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { StateGraph, START, END, MessagesZodMeta } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import { AIMessage, BaseMessage } from "@langchain/core/messages";
  import * as z from "zod";

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  // 创建内存数据库
  const db: typeof Database.prototype = new Database(":memory:");

  const model = new ChatAnthropic({ model: "claude-3-5-sonnet-20240620" });

  const callModel = async (state: z.infer<typeof MessagesZodState>) => {
    const response = await model.invoke(state.messages);
    return { messages: [response] };
  };

  const queryDatabase = async (state: z.infer<typeof MessagesZodState>) => {
    const queryResult: string = JSON.stringify(
      db.prepare("SELECT * FROM Artist LIMIT 10;").all(),
    );

    return { messages: [new AIMessage({ content: "queryResult" })] };
  };

  const workflow = new StateGraph(MessagesZodState)
    // 定义我们将在其间循环的两个节点
    .addNode("call_model", callModel, { retryPolicy: { maxAttempts: 5 } })
    .addNode("query_database", queryDatabase, {
      retryPolicy: {
        retryOn: (e: any): boolean => {
          if (e instanceof Database.SqliteError) {
            // 在 "SQLITE_BUSY" 错误时重试
            return e.code === "SQLITE_BUSY";
          }
          return false; // 不在其他错误时重试
        },
      },
    })
    .addEdge(START, "call_model")
    .addEdge("call_model", "query_database")
    .addEdge("query_database", END);

  const graph = workflow.compile();
  ```

</Accordion>



## 创建步骤序列

<Info>
**先决条件**
本指南假设您熟悉上面关于[状态](#define-and-update-state)的部分。
</Info>

这里我们演示如何构建一个简单的步骤序列。我们将展示：

1. 如何构建顺序图
2. 用于构建类似图的内置简写。



要添加节点序列，我们使用[图](/oss/javascript/langgraph/graph-api#stategraph)的 `.addNode` 和 `.addEdge` 方法：

```typescript
import { START, StateGraph } from "@langchain/langgraph";

const builder = new StateGraph(State)
  .addNode("step1", step1)
  .addNode("step2", step2)
  .addNode("step3", step3)
  .addEdge(START, "step1")
  .addEdge("step1", "step2")
  .addEdge("step2", "step3");
```


<Accordion title="为什么使用 LangGraph 将应用程序步骤拆分为序列？">

LangGraph 使向应用程序添加底层持久化层变得容易。
这允许在节点执行之间对状态进行检查点保存，因此您的 LangGraph 节点控制：

* 状态更新如何被[检查点保存](/oss/javascript/langgraph/persistence)
* 在[人机交互](/oss/javascript/langgraph/interrupts)工作流中如何恢复中断
* 如何使用 LangGraph 的[时间旅行](/oss/javascript/langgraph/use-time-travel)功能"倒带"和分支执行

它们还确定执行步骤如何[流式传输](/oss/javascript/langgraph/streaming)，以及如何使用 [Studio](/langsmith/studio) 可视化和调试您的应用程序。

让我们演示一个端到端的示例。我们将创建一个包含三个步骤的序列：

1. 在状态的键中填充一个值
2. 更新相同的值
3. 填充不同的值

让我们首先定义我们的[状态](/oss/javascript/langgraph/graph-api#state)。这控制图的[模式](/oss/javascript/langgraph/graph-api#schema)，也可以指定如何应用更新。有关更多详细信息，请参阅[此部分](#process-state-updates-with-reducers)。

在我们的例子中，我们只跟踪两个值：



```typescript
import * as z from "zod";

const State = z.object({
  value1: z.string(),
  value2: z.number(),
});
```




我们的[节点](/oss/javascript/langgraph/graph-api#nodes)只是读取图状态并对其进行更新的 TypeScript 函数。此函数的第一个参数始终是状态：

```typescript
const step1 = (state: z.infer<typeof State>) => {
  return { value1: "a" };
};

const step2 = (state: z.infer<typeof State>) => {
  const currentValue1 = state.value1;
  return { value1: `${currentValue1} b` };
};

const step3 = (state: z.infer<typeof State>) => {
  return { value2: 10 };
};
```


<Note>
请注意，在向状态发出更新时，每个节点只需指定它希望更新的键的值。

默认情况下，这将**覆盖**相应键的值。您也可以使用 [reducers](/oss/javascript/langgraph/graph-api#reducers) 来控制如何处理更新——例如，您可以将连续更新追加到键。有关更多详细信息，请参阅[此部分](#process-state-updates-with-reducers)。
</Note>

最后，我们定义图。我们使用 [StateGraph](/oss/javascript/langgraph/graph-api#stategraph) 来定义一个在此状态上操作的图。



然后我们将使用 [addNode](/oss/javascript/langgraph/graph-api#nodes) 和 [addEdge](/oss/javascript/langgraph/graph-api#edges) 来填充我们的图并定义其控制流。

```typescript
import { START, StateGraph } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("step1", step1)
  .addNode("step2", step2)
  .addNode("step3", step3)
  .addEdge(START, "step1")
  .addEdge("step1", "step2")
  .addEdge("step2", "step3")
  .compile();
```




<Tip>
**指定自定义名称**
您可以使用 `.addNode` 为节点指定自定义名称：

```typescript
const graph = new StateGraph(State)
.addNode("myNode", step1)
.compile();
```
</Tip>


请注意：



* `.addEdge` 接受节点的名称，对于函数，默认值为 `node.name`。
* 我们必须指定图的入口点。为此，我们添加一条与 [START 节点](/oss/javascript/langgraph/graph-api#start-node) 的边。
* 当没有更多节点要执行时，图会停止。

接下来我们[编译](/oss/javascript/langgraph/graph-api#compiling-your-graph)我们的图。这提供了对图结构的一些基本检查（例如，识别孤立节点）。如果我们通过 [checkpointer](/oss/javascript/langgraph/persistence) 向应用程序添加持久化，它也会在这里传递。


LangGraph 提供了内置的工具来可视化您的图。让我们检查我们的序列。有关可视化的详细信息，请参阅[此指南](#visualize-your-graph)。



```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


让我们进行一个简单的调用：



```typescript
const result = await graph.invoke({ value1: "c" });
console.log(result);
```

```
{ value1: 'a b', value2: 10 }
```


请注意：

* 我们通过为单个状态键提供值来启动调用。我们必须始终为至少一个键提供值。
* 我们传入的值被第一个节点覆盖。
* 第二个节点更新了该值。
* 第三个节点填充了一个不同的值。



</Accordion>

## 创建分支

节点的并行执行对于加速整体图操作至关重要。LangGraph 提供对节点并行执行的原生支持，这可以显著提高基于图的工作流的性能。这种并行化通过扇出和扇入机制实现，利用标准边和[条件边](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.MessageGraph.add_conditional_edges)。下面是一些示例，展示如何添加创建适合您的分支数据流。

### 并行运行图节点

在此示例中，我们从 `Node A` 扇出到 `B and C`，然后扇入到 `D`。对于我们的状态，[我们指定 reducer add 操作](/oss/javascript/langgraph/graph-api#reducers)。这将合并或累积状态中特定键的值，而不是简单地覆盖现有值。对于列表，这意味着将新列表与现有列表连接。有关使用 reducers 更新状态的更多详细信息，请参阅上面关于[状态 reducers](#process-state-updates-with-reducers)的部分。



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // The reducer makes this append-only
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Adding "A" to ${state.aggregate}`);
  return { aggregate: ["A"] };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Adding "B" to ${state.aggregate}`);
  return { aggregate: ["B"] };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log(`Adding "C" to ${state.aggregate}`);
  return { aggregate: ["C"] };
};

const nodeD = (state: z.infer<typeof State>) => {
  console.log(`Adding "D" to ${state.aggregate}`);
  return { aggregate: ["D"] };
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addNode("c", nodeC)
  .addNode("d", nodeD)
  .addEdge(START, "a")
  .addEdge("a", "b")
  .addEdge("a", "c")
  .addEdge("b", "d")
  .addEdge("c", "d")
  .addEdge("d", END)
  .compile();
```




```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


使用 reducer，您可以看到每个节点中添加的值都被累积了。



```typescript
const result = await graph.invoke({
  aggregate: [],
});
console.log(result);
```

```
Adding "A" to []
Adding "B" to ['A']
Adding "C" to ['A']
Adding "D" to ['A', 'B', 'C']
{ aggregate: ['A', 'B', 'C', 'D'] }
```


<Note>
在上面的示例中，节点 `"b"` 和 `"c"` 在同一[超级步骤](/oss/javascript/langgraph/graph-api#graphs)中并发执行。因为它们在同一步骤中，节点 `"d"` 在 `"b"` 和 `"c"` 都完成后执行。

重要的是，来自并行超级步骤的更新可能不会一致地排序。如果您需要并行超级步骤的更新具有一致、预定的顺序，您应该将输出写入状态中的单独字段，并带有一个用于排序的值。
</Note>

<Accordion title="异常处理？">
  LangGraph 在[超级步骤](/oss/javascript/langgraph/graph-api#graphs)内执行节点，这意味着虽然并行分支并行执行，但整个超级步骤是**事务性的**。如果这些分支中的任何一个引发异常，**不会**将任何更新应用到状态（整个超级步骤出错）。

  重要的是，当使用 [checkpointer](/oss/javascript/langgraph/persistence) 时，超级步骤内成功节点的结果会被保存，并且在恢复时不会重复。

  如果您有容易出错的节点（可能想要处理不稳定的 API 调用），LangGraph 提供了两种方法来解决这个问题：

  1. 您可以在节点内编写常规的 python 代码来捕获和处理异常。
  2. 您可以设置 **[retry_policy](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.RetryPolicy)** 来指示图重试引发某些类型异常的节点。只重试失败的分支，因此您不必担心执行冗余工作。

  总之，这些让您可以执行并行执行并完全控制异常处理。
</Accordion>



<Tip>
**设置最大并发数**
您可以通过在调用图时在[配置](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.LangGraphRunnableConfig.html)中设置 `max_concurrency` 来控制最大并发任务数。

```typescript
const result = await graph.invoke({ value1: "c" }, {configurable: {max_concurrency: 10}});
```
</Tip>




### 条件分支



如果您的扇出应该根据状态在运行时变化，您可以使用 [`addConditionalEdges`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.StateGraph.html#addconditionaledges) 使用图状态选择一个或多个路径。请参阅下面的示例，其中节点 `a` 生成一个状态更新，该更新确定下一个节点。

```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
  // 向状态添加一个键。我们将设置此键来确定
  // 如何进行分支。
  which: z.string().register(registry, {  // [!code highlight]
    reducer: {
      fn: (x, y) => y ?? x,
    },
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Adding "A" to ${state.aggregate}`);
  return { aggregate: ["A"], which: "c" };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Adding "B" to ${state.aggregate}`);
  return { aggregate: ["B"] };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log(`Adding "C" to ${state.aggregate}`);
  return { aggregate: ["C"] };  // [!code highlight]
};

const conditionalEdge = (state: z.infer<typeof State>): "b" | "c" => {
  // 在这里填入使用状态的任意逻辑
  // 以确定下一个节点
  return state.which as "b" | "c";
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addNode("c", nodeC)
  .addEdge(START, "a")
  .addEdge("b", END)
  .addEdge("c", END)
  .addConditionalEdges("a", conditionalEdge)
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

```typescript
const result = await graph.invoke({ aggregate: [] });
console.log(result);
```

```
Adding "A" to []
Adding "C" to ['A']
{ aggregate: ['A', 'C'], which: 'c' }
```


<Tip>
您的条件边可以路由到多个目标节点。例如：



```typescript
const routeBcOrCd = (state: z.infer<typeof State>): string[] => {
if (state.which === "cd") {
return ["c", "d"];
}
return ["b", "c"];
};
```

</Tip>

## Map-Reduce 和 Send API

LangGraph 支持使用 Send API 进行 map-reduce 和其他高级分支模式。以下是如何使用它的示例：



```typescript
import { StateGraph, START, END, Send } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const OverallState = z.object({
  topic: z.string(),
  subjects: z.array(z.string()),
  jokes: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
  }),
  bestSelectedJoke: z.string(),
});

const generateTopics = (state: z.infer<typeof OverallState>) => {
  return { subjects: ["lions", "elephants", "penguins"] };
};

const generateJoke = (state: { subject: string }) => {
  const jokeMap: Record<string, string> = {
    lions: "Why don't lions like fast food? Because they can't catch it!",
    elephants: "Why don't elephants use computers? They're afraid of the mouse!",
    penguins: "Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice."
  };
  return { jokes: [jokeMap[state.subject]] };
};

const continueToJokes = (state: z.infer<typeof OverallState>) => {
  return state.subjects.map((subject) => new Send("generateJoke", { subject }));
};

const bestJoke = (state: z.infer<typeof OverallState>) => {
  return { bestSelectedJoke: "penguins" };
};

const graph = new StateGraph(OverallState)
  .addNode("generateTopics", generateTopics)
  .addNode("generateJoke", generateJoke)
  .addNode("bestJoke", bestJoke)
  .addEdge(START, "generateTopics")
  .addConditionalEdges("generateTopics", continueToJokes)
  .addEdge("generateJoke", "bestJoke")
  .addEdge("bestJoke", END)
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

```typescript
// 调用图：这里我们调用它来生成一个笑话列表
for await (const step of await graph.stream({ topic: "animals" })) {
  console.log(step);
}
```

```
{ generateTopics: { subjects: [ 'lions', 'elephants', 'penguins' ] } }
{ generateJoke: { jokes: [ "Why don't lions like fast food? Because they can't catch it!" ] } }
{ generateJoke: { jokes: [ "Why don't elephants use computers? They're afraid of the mouse!" ] } }
{ generateJoke: { jokes: [ "Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice." ] } }
{ bestJoke: { bestSelectedJoke: 'penguins' } }
```


## 创建和控制循环

创建带循环的图时，我们需要一个终止执行的机制。最常见的方法是通过添加一个[条件边](/oss/javascript/langgraph/graph-api#conditional-edges)，一旦达到某个终止条件，就路由到 [END](/oss/javascript/langgraph/graph-api#end-node) 节点。

您也可以在调用或流式传输图时设置图的递归限制。递归限制设置图在引发错误之前允许执行的[超级步骤](/oss/javascript/langgraph/graph-api#graphs)数。有关递归限制概念的更多信息，请参阅[此处](/oss/javascript/langgraph/graph-api#recursion-limit)。

让我们考虑一个带循环的简单图，以更好地理解这些机制的工作原理。

<Tip>
要返回状态的最后一个值而不是收到递归限制错误，请参阅[下一节](#impose-a-recursion-limit)。
</Tip>

创建循环时，您可以包含一个指定终止条件的条件边：



```typescript
const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addEdge(START, "a")
  .addConditionalEdges("a", route)
  .addEdge("b", "a")
  .compile();

const route = (state: z.infer<typeof State>): "b" | typeof END => {
  if (terminationCondition(state)) {
    return END;
  } else {
    return "b";
  }
};
```


要控制递归限制，请在配置中指定 `"recursionLimit"`。这将引发 `GraphRecursionError`，您可以捕获并处理它：



```typescript
import { GraphRecursionError } from "@langchain/langgraph";

try {
  await graph.invoke(inputs, { recursionLimit: 3 });
} catch (error) {
  if (error instanceof GraphRecursionError) {
    console.log("Recursion Error");
  }
}
```


让我们定义一个带简单循环的图。请注意，我们使用条件边来实现终止条件。



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // The reducer makes this append-only
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Node A sees ${state.aggregate}`);
  return { aggregate: ["A"] };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Node B sees ${state.aggregate}`);
  return { aggregate: ["B"] };
};

// 定义边
const route = (state: z.infer<typeof State>): "b" | typeof END => {
  if (state.aggregate.length < 7) {
    return "b";
  } else {
    return END;
  }
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addEdge(START, "a")
  .addConditionalEdges("a", route)
  .addEdge("b", "a")
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


这种架构类似于 [ReAct 代理](/oss/javascript/langgraph/workflows-agents)，其中节点 `"a"` 是工具调用模型，节点 `"b"` 代表工具。

在我们的 `route` 条件边中，我们指定应该在状态中的 `"aggregate"` 列表超过阈值长度后结束。

调用图时，我们看到在达到终止条件之前，我们在节点 `"a"` 和 `"b"` 之间交替。



```typescript
const result = await graph.invoke({ aggregate: [] });
console.log(result);
```

```
Node A sees []
Node B sees ['A']
Node A sees ['A', 'B']
Node B sees ['A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B']
Node B sees ['A', 'B', 'A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B', 'A', 'B']
{ aggregate: ['A', 'B', 'A', 'B', 'A', 'B', 'A'] }
```


### 强制递归限制

在某些应用程序中，我们可能无法保证会达到给定的终止条件。在这些情况下，我们可以设置图的[递归限制](/oss/javascript/langgraph/graph-api#recursion-limit)。这将在给定数量的[超级步骤](/oss/javascript/langgraph/graph-api#graphs)后引发 `GraphRecursionError`。然后我们可以捕获并处理此异常：



```typescript
import { GraphRecursionError } from "@langchain/langgraph";

try {
  await graph.invoke({ aggregate: [] }, { recursionLimit: 4 });
} catch (error) {
  if (error instanceof GraphRecursionError) {
    console.log("Recursion Error");
  }
}
```

```
Node A sees []
Node B sees ['A']
Node A sees ['A', 'B']
Node B sees ['A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B']
Recursion Error
```








## 使用 `Command` 组合控制流和状态更新

将控制流（边）和状态更新（节点）组合在一起可能很有用。例如，您可能希望在**同一个节点**中**同时**执行状态更新**并**决定下一个要访问的节点。LangGraph 提供了一种方法，通过从节点函数返回 [Command](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Command) 对象来实现：



```typescript
import { Command } from "@langchain/langgraph";

const myNode = (state: State): Command => {
  return new Command({
    // state update
    update: { foo: "bar" },
    // control flow
    goto: "myOtherNode"
  });
};
```


下面我们展示一个端到端的示例。让我们创建一个包含 3 个节点的简单图：A、B 和 C。我们将首先执行节点 A，然后根据节点 A 的输出决定下一步是转到节点 B 还是节点 C。



```typescript
import { StateGraph, START, Command } from "@langchain/langgraph";
import * as z from "zod";

// 定义图状态
const State = z.object({
  foo: z.string(),
});

// 定义节点

const nodeA = (state: z.infer<typeof State>): Command => {
  console.log("Called A");
  const value = Math.random() > 0.5 ? "b" : "c";
  // 这是条件边函数的替代
  const goto = value === "b" ? "nodeB" : "nodeC";

  // 注意 Command 如何允许您同时更新图状态并路由到下一个节点
  return new Command({
    // 这是状态更新
    update: { foo: value },
    // 这是边的替代
    goto,
  });
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log("Called B");
  return { foo: state.foo + "b" };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log("Called C");
  return { foo: state.foo + "c" };
};
```

现在我们可以使用上述节点创建 `StateGraph`。请注意，图没有用于路由的[条件边](/oss/javascript/langgraph/graph-api#conditional-edges)！这是因为控制流是在 `nodeA` 内部使用 `Command` 定义的。

```typescript
const graph = new StateGraph(State)
  .addNode("nodeA", nodeA, {
    ends: ["nodeB", "nodeC"],
  })
  .addNode("nodeB", nodeB)
  .addNode("nodeC", nodeC)
  .addEdge(START, "nodeA")
  .compile();
```

<Warning>
您可能已经注意到我们使用 `ends` 来指定 `nodeA` 可以导航到哪些节点。这对于图渲染是必要的，并告诉 LangGraph `nodeA` 可以导航到 `nodeB` 和 `nodeC`。
</Warning>

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

If we run the graph multiple times, we'd see it take different paths (A -> B or A -> C) based on the random choice in node A.

```typescript
const result = await graph.invoke({ foo: "" });
console.log(result);
```

```
Called A
Called C
{ foo: 'cc' }
```


### 导航到父图中的节点

如果您使用[子图](/oss/javascript/langgraph/use-subgraphs)，您可能希望从子图内的节点导航到不同的子图（即父图中的不同节点）。为此，您可以在 `Command` 中指定 `graph=Command.PARENT`：



```typescript
const myNode = (state: State): Command => {
  return new Command({
    update: { foo: "bar" },
    goto: "otherSubgraph",  // 其中 `otherSubgraph` 是父图中的节点
    graph: Command.PARENT
  });
};
```


让我们使用上面的示例来演示这一点。我们将通过将上面示例中的 `nodeA` 更改为单节点图来实现，我们将把它作为子图添加到父图中。

<Warning>
**使用 `Command.PARENT` 进行状态更新**
当您从子图节点向父图节点发送更新，且该键由父图和子图[状态模式](/oss/javascript/langgraph/graph-api#schema)共享时，您**必须**在父图状态中为您正在更新的键定义一个 [reducer](/oss/javascript/langgraph/graph-api#reducers)。请参阅下面的示例。
</Warning>



```typescript
import { StateGraph, START, Command } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // 注意：我们在这里定义一个 reducer
  foo: z.string().register(registry, {  // [!code highlight]
    reducer: {
      fn: (x, y) => x + y,
    },
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log("Called A");
  const value = Math.random() > 0.5 ? "nodeB" : "nodeC";

  // 注意 Command 如何允许您同时更新图状态并路由到下一个节点
  return new Command({
    update: { foo: "a" },  // [!code highlight]
    goto: value,
    // 这告诉 LangGraph 导航到父图中的 nodeB 或 nodeC
    // 注意：这将导航到相对于子图最近的父图
    graph: Command.PARENT,
  });
};

const subgraph = new StateGraph(State)
  .addNode("nodeA", nodeA, { ends: ["nodeB", "nodeC"] })
  .addEdge(START, "nodeA")
  .compile();

const nodeB = (state: z.infer<typeof State>) => {
  console.log("Called B");  // [!code highlight]
  // 注意：由于我们已经定义了一个 reducer，我们不需要手动追加
  // 新字符到现有的 'foo' 值。相反，reducer 会自动追加这些
  return { foo: "b" };
};  // [!code highlight]

const nodeC = (state: z.infer<typeof State>) => {
  console.log("Called C");
  return { foo: "c" };
};

const graph = new StateGraph(State)
  .addNode("subgraph", subgraph, { ends: ["nodeB", "nodeC"] })
  .addNode("nodeB", nodeB)
  .addNode("nodeC", nodeC)
  .addEdge(START, "subgraph")
  .compile();
```

```typescript
const result = await graph.invoke({ foo: "" });
console.log(result);
```

```
Called A
Called C
{ foo: 'ac' }
```


### 在工具内使用

一个常见的用例是从工具内部更新图状态。例如，在客户支持应用程序中，您可能希望在对话开始时根据客户的帐号或 ID 查找客户信息。要从工具更新图状态，您可以从工具返回 `Command(update={"my_custom_key": "foo", "messages": [...]})`：



```typescript
import { tool } from "@langchain/core/tools";
import { Command } from "@langchain/langgraph";
import * as z from "zod";

const lookupUserInfo = tool(
  async (input, config) => {
    const userId = config.configurable?.userId;
    const userInfo = getUserInfo(userId);
    return new Command({
      update: {
        // 更新状态键
        userInfo: userInfo,
        // 更新消息历史
        messages: [{
          role: "tool",
          content: "Successfully looked up user information",
          tool_call_id: config.toolCall.id
        }]
      }
    });
  },
  {
    name: "lookupUserInfo",
    description: "使用此工具查找用户信息以更好地帮助他们解决问题。",
    schema: z.object({}),
  }
);
```


<Warning>
从工具返回 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html) 时，您**必须**在 `Command.update` 中包含 `messages`（或用于消息历史的任何状态键），并且 `messages` 中的消息列表**必须**包含 `ToolMessage`。这对于生成的消息历史是有效的（LLM 提供商要求带有工具调用的 AI 消息后面跟着工具结果消息）。
</Warning>

如果您使用通过 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html) 更新状态的工具，我们建议使用预构建的 [`ToolNode`](https://reference.langchain.com/javascript/classes/langchain.index.ToolNode.html)，它会自动处理返回 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html) 对象的工具并将它们传播到图状态。如果您正在编写调用工具的自定义节点，则需要手动将工具返回的 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html) 对象作为节点的更新进行传播。

## 可视化您的图

这里我们演示如何可视化您创建的图。

您可以可视化任何任意[图](https://langchain-ai.github.io/langgraph/reference/graphs/)，包括 [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph)。



让我们创建一个简单的示例图来演示可视化。

```typescript
import { StateGraph, START, END, MessagesZodMeta } from "@langchain/langgraph";
import { BaseMessage } from "@langchain/core/messages";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  value: z.number().register(registry, {
    reducer: {
      fn: (x, y) => x + y,
    },
  }),
});

const app = new StateGraph(State)
  .addNode("node1", (state) => {
    return { value: state.value + 1 };
  })
  .addNode("node2", (state) => {
    return { value: state.value * 2 };
  })
  .addEdge(START, "node1")
  .addConditionalEdges("node1", (state) => {
    if (state.value < 10) {
      return "node2";
    }
    return END;
  })
  .addEdge("node2", "node1")
  .compile();
```


### Mermaid

我们也可以将图类转换为 Mermaid 语法。



```typescript
const drawableGraph = await app.getGraphAsync();
console.log(drawableGraph.drawMermaid());
```

```
%%{init: {'flowchart': {'curve': 'linear'}}}%%
graph TD;
    tart__([<p>__start__</p>]):::first
    e1(node1)
    e2(node2)
    nd__([<p>__end__</p>]):::last
    tart__ --> node1;
    e1 -.-> node2;
    e1 -.-> __end__;
    e2 --> node1;
    ssDef default fill:#f2f0ff,line-height:1.2
    ssDef first fill-opacity:0
    ssDef last fill:#bfb6fc
```


### PNG



如果愿意，我们可以将图渲染为 `.png`。这使用 Mermaid.ink API 生成图表。

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await app.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langgraph\use-graph-api.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
