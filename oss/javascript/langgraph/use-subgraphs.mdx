---
title: 子图
sidebarTitle: 子图
---



本指南解释了使用子图的机制。子图是一个用作另一个图中的[节点](/oss/javascript/langgraph/graph-api#nodes)的[图](/oss/javascript/langgraph/graph-api#graphs)。

子图适用于：
- 构建[多智能体系统](/oss/javascript/langchain/multi-agent)
- 在多个图中重用一组节点
- 分布式开发：当您希望不同团队独立处理图的不同部分时，可以将每个部分定义为子图，只要遵守子图接口（输入和输出模式），父图就可以在不知道子图任何细节的情况下构建

添加子图时，您需要定义父图和子图如何通信：

* [从节点调用图](#invoke-a-graph-from-a-node) — 子图从父图中的节点内部调用
* [将图添加为节点](#add-a-graph-as-a-node) — 子图直接作为节点添加到父图中，并与父图**共享[状态键](/oss/javascript/langgraph/graph-api#state)**

## 设置



```bash
npm install @langchain/langgraph
```


<Tip>
**为 LangGraph 开发设置 LangSmith**
注册 [LangSmith](https://smith.langchain.com) 以快速发现问题并提高 LangGraph 项目的性能。LangSmith 允许您使用跟踪数据来调试、测试和监控使用 LangGraph 构建的 LLM 应用程序 — 在此处了解更多关于如何开始的信息](https://docs.smith.langchain.com)。
</Tip>


## 从节点调用图

实现子图的一种简单方法是从另一个图的节点内部调用图。在这种情况下，子图可以具有与父图**完全不同的模式**（无共享键）。例如，您可能希望为[多智能体](/oss/javascript/langchain/multi-agent)系统中的每个智能体保留私有消息历史记录。

如果您的应用程序属于这种情况，您需要定义一个**调用子图的节点函数**。此函数需要在调用子图之前将输入（父）状态转换为子图状态，并在从节点返回状态更新之前将结果转换回父状态。



```typescript
import { StateGraph, START } from "@langchain/langgraph";
import * as z from "zod";

const SubgraphState = z.object({
  bar: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(SubgraphState)
  .addNode("subgraphNode1", (state) => {
    return { bar: "hi! " + state.bar };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const State = z.object({
  foo: z.string(),
});

// 将状态转换为子图状态并转换回来
const builder = new StateGraph(State)
  .addNode("node1", async (state) => {
    const subgraphOutput = await subgraph.invoke({ bar: state.foo });
    return { foo: subgraphOutput.bar };
  })
  .addEdge(START, "node1");

const graph = builder.compile();
```


<Accordion title="完整示例：不同的状态模式">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // 定义子图
  const SubgraphState = z.object({
    // 注意：这些键都不与父图状态共享
    bar: z.string(),
    baz: z.string(),
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { baz: "baz" };
    })
    .addNode("subgraphNode2", (state) => {
      return { bar: state.bar + state.baz };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // 定义父图
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", async (state) => {
      const response = await subgraph.invoke({ bar: state.foo });   // [!code highlight]
      return { foo: response.bar };   // [!code highlight]
    })
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream(
    { foo: "foo" },
    { subgraphs: true }
  )) {
    console.log(chunk);
  }
  ```

  1. 将状态转换为子图状态
  2. 将响应转换回父状态

  ```
  [[], { node1: { foo: 'hi! foo' } }]
  [['node2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7'], { subgraphNode1: { baz: 'baz' } }]
  [['node2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7'], { subgraphNode2: { bar: 'hi! foobaz' } }]
  [[], { node2: { foo: 'hi! foobaz' } }]
  ```

</Accordion>

<Accordion title="完整示例：不同的状态模式（两级子图）">
  这是一个两级子图的示例：父 -> 子 -> 孙。



  ```typescript
  import { StateGraph, START, END } from "@langchain/langgraph";
  import * as z from "zod";

  // 孙图
  const GrandChildState = z.object({
    myGrandchildKey: z.string(),
  });

  const grandchild = new StateGraph(GrandChildState)
    .addNode("grandchild1", (state) => {
      // 注意：子或父键在此处不可访问
      return { myGrandchildKey: state.myGrandchildKey + ", how are you" };
    })
    .addEdge(START, "grandchild1")
    .addEdge("grandchild1", END);

  const grandchildGraph = grandchild.compile();

  // 子图
  const ChildState = z.object({
    myChildKey: z.string(),
  });

  const child = new StateGraph(ChildState)
    .addNode("child1", async (state) => {
      // 注意：父或孙键在此处不可访问
      const grandchildGraphInput = { myGrandchildKey: state.myChildKey };   // [!code highlight]
      const grandchildGraphOutput = await grandchildGraph.invoke(grandchildGraphInput);
      return { myChildKey: grandchildGraphOutput.myGrandchildKey + " today?" };   // [!code highlight]
    })   // [!code highlight]
    .addEdge(START, "child1")
    .addEdge("child1", END);

  const childGraph = child.compile();

  // 父图
  const ParentState = z.object({
    myKey: z.string(),
  });

  const parent = new StateGraph(ParentState)
    .addNode("parent1", (state) => {
      // 注意：子或孙键在此处不可访问
      return { myKey: "hi " + state.myKey };
    })
    .addNode("child", async (state) => {
      const childGraphInput = { myChildKey: state.myKey };   // [!code highlight]
      const childGraphOutput = await childGraph.invoke(childGraphInput);
      return { myKey: childGraphOutput.myChildKey };   // [!code highlight]
    })   // [!code highlight]
    .addNode("parent2", (state) => {
      return { myKey: state.myKey + " bye!" };
    })
    .addEdge(START, "parent1")
    .addEdge("parent1", "child")
    .addEdge("child", "parent2")
    .addEdge("parent2", END);

  const parentGraph = parent.compile();

  for await (const chunk of await parentGraph.stream(
    { myKey: "Bob" },
    { subgraphs: true }
  )) {
    console.log(chunk);
  }
  ```

  1. 我们将状态从子状态通道（`myChildKey`）转换为孙状态通道（`myGrandchildKey`）
  2. 我们将状态从孙状态通道（`myGrandchildKey`）转换回子状态通道（`myChildKey`）
  3. 我们在这里传递一个函数，而不仅仅是编译的图（`grandchildGraph`）
  4. 我们将状态从父状态通道（`myKey`）转换为子状态通道（`myChildKey`）
  5. 我们将状态从子状态通道（`myChildKey`）转换回父状态通道（`myKey`）
  6. 我们在这里传递一个函数，而不仅仅是编译的图（`childGraph`）

  ```
  [[], { parent1: { myKey: 'hi Bob' } }]
  [['child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b', 'child1:781bb3b1-3971-84ce-810b-acf819a03f9c'], { grandchild1: { myGrandchildKey: 'hi Bob, how are you' } }]
  [['child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b'], { child1: { myChildKey: 'hi Bob, how are you today?' } }]
  [[], { child: { myKey: 'hi Bob, how are you today?' } }]
  [[], { parent2: { myKey: 'hi Bob, how are you today? bye!' } }]
  ```

</Accordion>

## 将图添加为节点

当父图和子图可以通过[模式](/oss/javascript/langgraph/graph-api#state)中的共享状态键（通道）进行通信时，您可以将图作为[节点](/oss/javascript/langgraph/graph-api#nodes)添加到另一个图中。例如，在[多智能体](/oss/javascript/langchain/multi-agent)系统中，智能体通常通过共享的[messages](/oss/javascript/langgraph/graph-api#why-use-messages)键进行通信。

<img
  src="/oss/images/subgraph.png"
  alt="SQL agent graph"
  style={{ height: "450px" }}
/>

如果您的子图与父图共享状态键，您可以按照以下步骤将其添加到图中：



1. 定义子图工作流（下面示例中的 `subgraphBuilder`）并编译它
2. 在定义父图工作流时，将编译的子图传递给 `.addNode` 方法

```typescript
import { StateGraph, START } from "@langchain/langgraph";
import * as z from "zod";

const State = z.object({
  foo: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(State)
  .addNode("subgraphNode1", (state) => {
    return { foo: "hi! " + state.foo };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const builder = new StateGraph(State)
  .addNode("node1", subgraph)
  .addEdge(START, "node1");

const graph = builder.compile();
```


<Accordion title="完整示例：共享状态模式">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // 定义子图
  const SubgraphState = z.object({
    foo: z.string(),    // [!code highlight]
    bar: z.string(),    // [!code highlight]
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { bar: "bar" };
    })
    .addNode("subgraphNode2", (state) => {
      // 注意：此节点使用的是仅在子图中可用的状态键（'bar'）
      // 并在共享状态键（'foo'）上发送更新
      return { foo: state.foo + state.bar };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // 定义父图
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", subgraph)
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream({ foo: "foo" })) {
    console.log(chunk);
  }
  ```

  1. 此键与父图状态共享
  2. 此键是 `SubgraphState` 私有的，对父图不可见

  ```
  { node1: { foo: 'hi! foo' } }
  { node2: { foo: 'hi! foobar' } }
  ```

</Accordion>

## 添加持久化

您只需要**在编译父图时提供检查点**。LangGraph 会自动将检查点传播到子子图。



```typescript
import { StateGraph, START, MemorySaver } from "@langchain/langgraph";
import * as z from "zod";

const State = z.object({
  foo: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(State)
  .addNode("subgraphNode1", (state) => {
    return { foo: state.foo + "bar" };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const builder = new StateGraph(State)
  .addNode("node1", subgraph)
  .addEdge(START, "node1");

const checkpointer = new MemorySaver();
const graph = builder.compile({ checkpointer });
```


如果您希望子图**拥有自己的内存**，可以使用适当的检查点选项编译它。这在[多智能体](/oss/javascript/langchain/multi-agent)系统中很有用，如果您希望智能体跟踪其内部消息历史记录：



```typescript
const subgraphBuilder = new StateGraph(...)
const subgraph = subgraphBuilder.compile({ checkpointer: true });
```


## 查看子图状态

当您启用[持久化](/oss/javascript/langgraph/persistence)时，可以通过适当的方法[检查图状态](/oss/javascript/langgraph/persistence#checkpoints)（检查点）。要查看子图状态，可以使用 subgraphs 选项。



您可以通过 `graph.getState(config)` 检查图状态。要查看子图状态，可以使用 `graph.getState(config, { subgraphs: true })`。


<Warning>
**仅在中断时可用**
子图状态只能在**子图被中断时**查看。一旦您恢复图，将无法访问子图状态。
</Warning>

<Accordion title="查看中断的子图状态">


  ```typescript
  import { StateGraph, START, MemorySaver, interrupt, Command } from "@langchain/langgraph";
  import * as z from "zod";

  const State = z.object({
    foo: z.string(),
  });

  // Subgraph
  const subgraphBuilder = new StateGraph(State)
    .addNode("subgraphNode1", (state) => {
      const value = interrupt("Provide value:");
      return { foo: state.foo + value };
    })
    .addEdge(START, "subgraphNode1");

  const subgraph = subgraphBuilder.compile();

  // Parent graph
  const builder = new StateGraph(State)
    .addNode("node1", subgraph)
    .addEdge(START, "node1");

  const checkpointer = new MemorySaver();
  const graph = builder.compile({ checkpointer });

  const config = { configurable: { thread_id: "1" } };

  await graph.invoke({ foo: "" }, config);
  const parentState = await graph.getState(config);
  const subgraphState = (await graph.getState(config, { subgraphs: true })).tasks[0].state;   // [!code highlight]

  // 恢复子图
  await graph.invoke(new Command({ resume: "bar" }), config);
  ```

</Accordion>

## 流式传输子图输出

要在流式输出中包含子图的输出，您可以在父图的 stream 方法中设置 subgraphs 选项。这将流式传输来自父图和任何子图的输出。



```typescript
for await (const chunk of await graph.stream(
  { foo: "foo" },
  {
    subgraphs: true,   // [!code highlight]
    streamMode: "updates",
  }
)) {
  console.log(chunk);
}
```

1. 设置 `subgraphs: true` 以流式传输子图的输出。


<Accordion title="从子图流式传输">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // 定义子图
  const SubgraphState = z.object({
    foo: z.string(),
    bar: z.string(),
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { bar: "bar" };
    })
    .addNode("subgraphNode2", (state) => {
      // 注意：此节点使用的是仅在子图中可用的状态键（'bar'）
      // 并在共享状态键（'foo'）上发送更新
      return { foo: state.foo + state.bar };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // 定义父图
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", subgraph)
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream(
    { foo: "foo" },
    {
      streamMode: "updates",
      subgraphs: true,   // [!code highlight]
    }
  )) {
    console.log(chunk);
  }
  ```

  1. 设置 `subgraphs: true` 以流式传输子图的输出。

  ```
  [[], { node1: { foo: 'hi! foo' } }]
  [['node2:e58e5673-a661-ebb0-70d4-e298a7fc28b7'], { subgraphNode1: { bar: 'bar' } }]
  [['node2:e58e5673-a661-ebb0-70d4-e298a7fc28b7'], { subgraphNode2: { foo: 'hi! foobar' } }]
  [[], { node2: { foo: 'hi! foobar' } }]
  ```

</Accordion>

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langgraph\use-subgraphs.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
