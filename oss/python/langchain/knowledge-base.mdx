---
title: 使用 LangChain 构建语义搜索引擎
sidebarTitle: 语义搜索
---



import EmbeddingsTabsPy from '/snippets/embeddings-tabs-py.mdx';
import EmbeddingsTabsJS from '/snippets/embeddings-tabs-js.mdx';
import VectorstoreTabsPy from '/snippets/vectorstore-tabs-py.mdx';
import VectorstoreTabsJS from '/snippets/vectorstore-tabs-js.mdx';

## 概述

本教程将帮助您熟悉 LangChain 的[文档加载器](/oss/python/langchain/retrieval#document-loaders)、[嵌入](/oss/python/langchain/retrieval#embedding-models)和[向量存储](/oss/python/langchain/retrieval#vector-store)抽象。这些抽象旨在支持从（向量）数据库和其他来源检索数据，以便与 LLM 工作流集成。它们对于获取数据以作为模型推理的一部分进行推理的应用很重要，例如检索增强生成或 [RAG](/oss/python/langchain/retrieval)。

在这里，我们将构建一个基于 PDF 文档的搜索引擎。这将使我们能够检索与输入查询相似的 PDF 段落。本指南还包括在搜索引擎之上的最小 RAG 实现。

### 概念

本指南侧重于文本数据的检索。我们将涵盖以下概念：

- [文档和文档加载器](/oss/python/integrations/document_loaders)；
- [文本分割器](/oss/python/integrations/splitters)；
- [嵌入](/oss/python/integrations/text_embedding)；
- [向量存储](/oss/python/integrations/vectorstores) 和[检索器](/oss/python/integrations/retrievers)。

## 设置

### 安装

本教程需要 `langchain-community` 和 `pypdf` 包：

<CodeGroup>
```bash pip
pip install langchain-community pypdf
```
```bash conda
conda install langchain-community pypdf -c conda-forge
```
</CodeGroup>





有关更多详细信息，请参阅我们的[安装指南](/oss/python/langchain/install)。

### LangSmith

您使用 LangChain 构建的许多应用将包含多个步骤和多次 LLM 调用。
随着这些应用变得越来越复杂，能够检查链或代理内部到底发生了什么变得至关重要。
最好的方法是使用 [LangSmith](https://smith.langchain.com)。

在上面的链接注册后，请确保设置环境变量以开始记录跟踪：

```shell
export LANGSMITH_TRACING="true"
export LANGSMITH_API_KEY="..."
```

Or, if in a notebook, you can set them with:

```python
import getpass
import os

os.environ["LANGSMITH_TRACING"] = "true"
os.environ["LANGSMITH_API_KEY"] = getpass.getpass()
```



## 1. 文档和文档加载器

LangChain 实现了 [Document](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 抽象，旨在表示文本单元和关联的元数据。它有三个属性：

- `page_content`: 表示内容的字符串；
- `metadata`: 包含任意元数据的字典；
- `id`: （可选）文档的字符串标识符。



`metadata` 属性可以捕获有关文档来源、与其他文档的关系以及其他信息。请注意，单个 [`Document`](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象通常表示较大文档的一个块。

We can generate sample documents when desired:

```python
from langchain_core.documents import Document

documents = [
    Document(
        page_content="Dogs are great companions, known for their loyalty and friendliness.",
        metadata={"source": "mammal-pets-doc"},
    ),
    Document(
        page_content="Cats are independent pets that often enjoy their own space.",
        metadata={"source": "mammal-pets-doc"},
    ),
]
```



但是，LangChain 生态系统实现了[文档加载器](/oss/python/langchain/retrieval#document-loaders)，它们[与数百个常见源集成](/oss/python/integrations/document_loaders/)。这使得将来自这些源的数据合并到您的 AI 应用中变得容易。

### 加载文档

让我们将 PDF 加载到 [`Document`](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象序列中。[这是一个示例 PDF](https://github.com/langchain-ai/langchain/blob/v0.3/docs/docs/example_data/nke-10k-2023.pdf) —— 2023 年 Nike 的 10-k 文件。我们可以查阅 LangChain 文档以了解[可用的 PDF 文档加载器](/oss/python/integrations/document_loaders/#pdfs)。

```python
from langchain_community.document_loaders import PyPDFLoader

file_path = "../example_data/nke-10k-2023.pdf"
loader = PyPDFLoader(file_path)

docs = loader.load()

print(len(docs))
```
```output
107
```

`PyPDFLoader` 为每个 PDF 页面加载一个 [`Document`](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象。对于每个对象，我们可以轻松访问：

- 页面的字符串内容；
- 包含文件名和页码的元数据。



```python
print(f"{docs[0].page_content[:200]}\n")
print(docs[0].metadata)
```
```output
Table of Contents
UNITED STATES
SECURITIES AND EXCHANGE COMMISSION
Washington, D.C. 20549
FORM 10-K
(Mark One)
☑ ANNUAL REPORT PURSUANT TO SECTION 13 OR 15(D) OF THE SECURITIES EXCHANGE ACT OF 1934
FO

{'source': '../example_data/nke-10k-2023.pdf', 'page': 0}
```



### 分割

对于信息检索和下游问答目的，页面可能是一个过于粗糙的表示。我们的最终目标是检索回答输入查询的 [`Document`](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象，进一步分割我们的 PDF 将有助于确保文档相关部分的含义不会被周围的文本"冲淡"。

我们可以为此目的使用[文本分割器](/oss/python/langchain/retrieval#text_splitters)。这里我们将使用一个基于字符进行分区的简单文本分割器。我们将把文档分割成 1000 个字符的块，块之间有 200 个字符的重叠。重叠有助于减少将语句与其相关的重要上下文分离的可能性。我们使用 `RecursiveCharacterTextSplitter`，它将使用常见分隔符（如换行符）递归分割文档，直到每个块达到适当的大小。这是通用文本用例推荐的文本分割器。

我们设置 `add_start_index=True`，以便将每个分割的 Document 在初始 Document 中开始的字符索引保存为元数据属性 "start_index"。

```python
from langchain_text_splitters import RecursiveCharacterTextSplitter

text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1000, chunk_overlap=200, add_start_index=True
)
all_splits = text_splitter.split_documents(docs)

print(len(all_splits))
```



```output
514
```


## 2. 嵌入

向量搜索是存储和搜索非结构化数据（如非结构化文本）的常用方法。其思想是存储与文本关联的数值向量。给定查询，我们可以将其[嵌入](/oss/python/langchain/retrieval#embedding_models)为相同维度的向量，并使用向量相似度指标（如余弦相似度）来识别相关文本。

LangChain 支持来自[数十个提供商的嵌入](/oss/python/integrations/text_embedding/)。这些模型指定如何将文本转换为数值向量。让我们选择一个模型：

<EmbeddingsTabsPy />

```python
vector_1 = embeddings.embed_query(all_splits[0].page_content)
vector_2 = embeddings.embed_query(all_splits[1].page_content)

assert len(vector_1) == len(vector_2)
print(f"Generated vectors of length {len(vector_1)}\n")
print(vector_1[:10])
```



```output
Generated vectors of length 1536

[-0.008586574345827103, -0.03341241180896759, -0.008936782367527485, -0.0036674530711025, 0.010564599186182022, 0.009598285891115665, -0.028587326407432556, -0.015824200585484505, 0.0030416189692914486, -0.012899317778646946]
```
有了生成文本嵌入的模型，我们可以接下来将它们存储在支持高效相似度搜索的特殊数据结构中。

## 3. 向量存储

LangChain [VectorStore](https://reference.langchain.com/python/langchain_core/vectorstores/?h=#langchain_core.vectorstores.base.VectorStore) 对象包含将文本和 [`Document`](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象添加到存储的方法，以及使用各种相似度指标查询它们的方法。它们通常使用[嵌入](/oss/python/langchain/retrieval#embedding_models)模型初始化，这些模型确定如何将文本数据转换为数值向量。

LangChain 包含一套与不同向量存储技术的[集成](/oss/python/integrations/vectorstores)。一些向量存储由提供商托管（例如，各种云提供商）并需要特定凭据才能使用；一些（如 [Postgres](/oss/python/integrations/vectorstores/pgvector)）在可以本地运行或通过第三方运行的单独基础设施中运行；其他可以在内存中运行以处理轻量级工作负载。让我们选择一个向量存储：

<VectorstoreTabsPy />



实例化向量存储后，我们现在可以索引文档。

```python
ids = vector_store.add_documents(documents=all_splits)
```



请注意，大多数向量存储实现将允许您连接到现有向量存储——例如，通过提供客户端、索引名称或其他信息。有关更多详细信息，请参阅特定[集成](/oss/python/integrations/vectorstores)的文档。

一旦我们实例化了一个包含文档的 [`VectorStore`](https://reference.langchain.com/python/langchain_core/vectorstores/?h=#langchain_core.vectorstores.base.VectorStore)，我们就可以查询它。[VectorStore](https://reference.langchain.com/python/langchain_core/vectorstores/?h=#langchain_core.vectorstores.base.VectorStore) 包含用于查询的方法：
- 同步和异步；
- 通过字符串查询和向量；
- 返回和不返回相似度分数；
- 通过相似度和 @[最大边际相关性][VectorStore.max_marginal_relevance_search]（以平衡与查询的相似度和检索结果的多样性）。

这些方法通常在其输出中包含 [Document](https://reference.langchain.com/python/langchain_core/documents/#langchain_core.documents.base.Document) 对象列表。

**用法**

嵌入通常将文本表示为"密集"向量，使得具有相似含义的文本在几何上接近。这使我们只需传入一个问题即可检索相关信息，而无需了解文档中使用的任何特定关键术语。

根据与字符串查询的相似度返回文档：

```python
results = vector_store.similarity_search(
    "How many distribution centers does Nike have in the US?"
)

print(results[0])
```
```output
page_content='direct to consumer operations sell products through the following number of retail stores in the United States:
U.S. RETAIL STORES NUMBER
NIKE Brand factory stores 213
NIKE Brand in-line stores (including employee-only stores) 74
Converse stores (including factory stores) 82
TOTAL 369
In the United States, NIKE has eight significant distribution centers. Refer to Item 2. Properties for further information.
2023 FORM 10-K 2' metadata={'page': 4, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 3125}
```



异步查询：

```python
results = await vector_store.asimilarity_search("When was Nike incorporated?")

print(results[0])
```
```output
page_content='Table of Contents
PART I
ITEM 1. BUSINESS
GENERAL
NIKE, Inc. was incorporated in 1967 under the laws of the State of Oregon. As used in this Annual Report on Form 10-K (this "Annual Report"), the terms "we," "us," "our,"
"NIKE" and the "Company" refer to NIKE, Inc. and its predecessors, subsidiaries and affiliates, collectively, unless the context indicates otherwise.
Our principal business activity is the design, development and worldwide marketing and selling of athletic footwear, apparel, equipment, accessories and services. NIKE is
the largest seller of athletic footwear and apparel in the world. We sell our products through NIKE Direct operations, which are comprised of both NIKE-owned retail stores
and sales through our digital platforms (also referred to as "NIKE Brand Digital"), to retail accounts and to a mix of independent distributors, licensees and sales' metadata={'page': 3, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}
```


返回分数：

```python
# 请注意，提供商实现不同的分数；这里的分数
# 是与相似度成反比的距离指标。

results = vector_store.similarity_search_with_score("What was Nike's revenue in 2023?")
doc, score = results[0]
print(f"Score: {score}\n")
print(doc)
```
```output
Score: 0.23699893057346344

page_content='Table of Contents
FISCAL 2023 NIKE BRAND REVENUE HIGHLIGHTS
The following tables present NIKE Brand revenues disaggregated by reportable operating segment, distribution channel and major product line:
FISCAL 2023 COMPARED TO FISCAL 2022
•NIKE, Inc. Revenues were $51.2 billion in fiscal 2023, which increased 10% and 16% compared to fiscal 2022 on a reported and currency-neutral basis, respectively.
The increase was due to higher revenues in North America, Europe, Middle East & Africa ("EMEA"), APLA and Greater China, which contributed approximately 7, 6,
2 and 1 percentage points to NIKE, Inc. Revenues, respectively.
•NIKE Brand revenues, which represented over 90% of NIKE, Inc. Revenues, increased 10% and 16% on a reported and currency-neutral basis, respectively. This
increase was primarily due to higher revenues in Men's, the Jordan Brand, Women's and Kids' which grew 17%, 35%,11% and 10%, respectively, on a wholesale
equivalent basis.' metadata={'page': 35, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}
```



根据与嵌入查询的相似度返回文档：

```python
embedding = embeddings.embed_query("How were Nike's margins impacted in 2023?")

results = vector_store.similarity_search_by_vector(embedding)
print(results[0])
```
```output
page_content='Table of Contents
GROSS MARGIN
FISCAL 2023 COMPARED TO FISCAL 2022
For fiscal 2023, our consolidated gross profit increased 4% to $22,292 million compared to $21,479 million for fiscal 2022. Gross margin decreased 250 basis points to
43.5% for fiscal 2023 compared to 46.0% for fiscal 2022 due to the following:
*Wholesale equivalent
The decrease in gross margin for fiscal 2023 was primarily due to:
•Higher NIKE Brand product costs, on a wholesale equivalent basis, primarily due to higher input costs and elevated inbound freight and logistics costs as well as
product mix;
•Lower margin in our NIKE Direct business, driven by higher promotional activity to liquidate inventory in the current period compared to lower promotional activity in
the prior period resulting from lower available inventory supply;
•Unfavorable changes in net foreign currency exchange rates, including hedges; and
•Lower off-price margin, on a wholesale equivalent basis.
This was partially offset by:' metadata={'page': 36, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}
```



了解更多：

- [API 参考](https://reference.langchain.com/python/langchain_core/vectorstores/?h=#langchain_core.vectorstores.base.VectorStore)
- [特定集成的文档](/oss/python/integrations/vectorstores)

## 4. 检索器

LangChain [`VectorStore`](https://reference.langchain.com/python/langchain_core/vectorstores/?h=#langchain_core.vectorstores.base.VectorStore) 对象不继承 @[Runnable]。LangChain @[Retrievers] 是 Runnables，因此它们实现了一组标准方法（例如，同步和异步 `invoke` 和 `batch` 操作）。虽然我们可以从向量存储构造检索器，但检索器也可以与非向量存储数据源（如外部 API）交互。

我们可以自己创建一个简单版本，而不需要子类化 `Retriever`。如果我们选择要用于检索文档的方法，我们可以轻松创建一个可运行对象。下面我们将围绕 `similarity_search` 方法构建一个：


```python
from typing import List

from langchain_core.documents import Document
from langchain_core.runnables import chain


@chain
def retriever(query: str) -> List[Document]:
    return vector_store.similarity_search(query, k=1)


retriever.batch(
    [
        "How many distribution centers does Nike have in the US?",
        "When was Nike incorporated?",
    ],
)
```



```output
[[Document(metadata={'page': 4, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 3125}, page_content='direct to consumer operations sell products through the following number of retail stores in the United States:\nU.S. RETAIL STORES NUMBER\nNIKE Brand factory stores 213 \nNIKE Brand in-line stores (including employee-only stores) 74 \nConverse stores (including factory stores) 82 \nTOTAL 369 \nIn the United States, NIKE has eight significant distribution centers. Refer to Item 2. Properties for further information.\n2023 FORM 10-K 2')],
 [Document(metadata={'page': 3, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}, page_content='Table of Contents\nPART I\nITEM 1. BUSINESS\nGENERAL\nNIKE, Inc. was incorporated in 1967 under the laws of the State of Oregon. As used in this Annual Report on Form 10-K (this "Annual Report"), the terms "we," "us," "our,"\n"NIKE" and the "Company" refer to NIKE, Inc. and its predecessors, subsidiaries and affiliates, collectively, unless the context indicates otherwise.\nOur principal business activity is the design, development and worldwide marketing and selling of athletic footwear, apparel, equipment, accessories and services. NIKE is\nthe largest seller of athletic footwear and apparel in the world. We sell our products through NIKE Direct operations, which are comprised of both NIKE-owned retail stores\nand sales through our digital platforms (also referred to as "NIKE Brand Digital"), to retail accounts and to a mix of independent distributors, licensees and sales')]]
```


向量存储实现一个 `as_retriever` 方法，该方法将生成一个检索器，具体是 [VectorStoreRetriever](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStoreRetriever.html)。这些检索器包括特定的 `search_type` 和 `search_kwargs` 属性，这些属性标识要调用的底层向量存储的方法以及如何参数化它们。例如，我们可以使用以下方式复制上述内容：

```python
retriever = vector_store.as_retriever(
    search_type="similarity",
    search_kwargs={"k": 1},
)

retriever.batch(
    [
        "How many distribution centers does Nike have in the US?",
        "When was Nike incorporated?",
    ],
)
```
```output
[[Document(metadata={'page': 4, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 3125}, page_content='direct to consumer operations sell products through the following number of retail stores in the United States:\nU.S. RETAIL STORES NUMBER\nNIKE Brand factory stores 213 \nNIKE Brand in-line stores (including employee-only stores) 74 \nConverse stores (including factory stores) 82 \nTOTAL 369 \nIn the United States, NIKE has eight significant distribution centers. Refer to Item 2. Properties for further information.\n2023 FORM 10-K 2')],
 [Document(metadata={'page': 3, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}, page_content='Table of Contents\nPART I\nITEM 1. BUSINESS\nGENERAL\nNIKE, Inc. was incorporated in 1967 under the laws of the State of Oregon. As used in this Annual Report on Form 10-K (this "Annual Report"), the terms "we," "us," "our,"\n"NIKE" and the "Company" refer to NIKE, Inc. and its predecessors, subsidiaries and affiliates, collectively, unless the context indicates otherwise.\nOur principal business activity is the design, development and worldwide marketing and selling of athletic footwear, apparel, equipment, accessories and services. NIKE is\nthe largest seller of athletic footwear and apparel in the world. We sell our products through NIKE Direct operations, which are comprised of both NIKE-owned retail stores\nand sales through our digital platforms (also referred to as "NIKE Brand Digital"), to retail accounts and to a mix of independent distributors, licensees and sales')]]
```

`VectorStoreRetriever` 支持 `"similarity"`（默认）、`"mmr"`（最大边际相关性，如上所述）和 `"similarity_score_threshold"` 的搜索类型。我们可以使用后者通过相似度分数对检索器输出的文档进行阈值处理。



检索器可以轻松集成到更复杂的应用中，例如[检索增强生成（RAG）](/oss/python/langchain/retrieval)应用，它将给定问题与检索到的上下文组合成 LLM 的提示。要了解有关构建此类应用的更多信息，请查看 [RAG 教程](/oss/python/langchain/rag)教程。


## 下一步

您现在已经了解了如何在 PDF 文档上构建语义搜索引擎。

有关文档加载器的更多信息：

- [概述](/oss/python/langchain/retrieval#document_loaders)
- [可用集成](/oss/python/integrations/document_loaders/)

有关嵌入的更多信息：

- [概述](/oss/python/langchain/retrieval#embedding_models/)
- [可用集成](/oss/python/integrations/text_embedding/)

有关向量存储的更多信息：

- [概述](/oss/python/langchain/retrieval#vectorstores/)
- [可用集成](/oss/python/integrations/vectorstores/)

有关 RAG 的更多信息，请参阅：

- [构建检索增强生成（RAG）应用](/oss/python/langchain/rag/)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\langchain\knowledge-base.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
