---
title: Deep Agents 中间件
sidebarTitle: 中间件
description: 了解驱动深度代理的中间件
---

深度代理使用模块化中间件架构构建。深度代理可以访问：

1. 规划工具
2. 用于存储上下文和长期记忆的文件系统
3. 生成子代理的能力

每个功能都作为单独的中间件实现。当您使用 `create_deep_agent` 创建深度代理时，我们会自动将 `TodoListMiddleware`、`FilesystemMiddleware` 和 `SubAgentMiddleware` 附加到您的代理。

中间件是可组合的——您可以根据需要向代理添加或多或少的中间件。您可以独立使用任何中间件。

以下部分说明每个中间件提供的内容。

## 待办事项列表中间件

规划是解决复杂问题的关键。如果您最近使用过 Claude Code，您会注意到它在处理复杂的多部分任务之前如何写出待办事项列表。您还会注意到它如何在获得更多信息时实时适应和更新此待办事项列表。

`TodoListMiddleware` 为您的代理提供一个专门用于更新此待办事项列表的工具。在执行多部分任务之前和期间，代理会被提示使用 `write_todos` 工具来跟踪它正在做什么以及仍需要做什么。

```python
from langchain.agents import create_agent
from langchain.agents.middleware import TodoListMiddleware

# TodoListMiddleware 默认包含在 create_deep_agent 中
# 如果构建自定义代理，可以自定义它
agent = create_agent(
    model="claude-sonnet-4-5-20250929",
    # 可以通过中间件添加自定义规划指令
    middleware=[
        TodoListMiddleware(
            system_prompt="Use the write_todos tool to..."  # 可选：系统提示的自定义添加
        ),
    ],
)
```




## 文件系统中间件

上下文工程是构建有效代理的主要挑战。在使用返回可变长度结果的工具（例如，web_search 和 rag）时尤其困难，因为长工具结果会快速填满您的上下文窗口。

`FilesystemMiddleware` 提供四个工具，用于与短期和长期内存交互：

- **ls**：列出文件系统中的文件
- **read_file**：读取整个文件或文件中的一定行数
- **write_file**：向文件系统写入新文件
- **edit_file**：编辑文件系统中的现有文件

```python
from langchain.agents import create_agent
from deepagents.middleware.filesystem import FilesystemMiddleware

# FilesystemMiddleware is included by default in create_deep_agent
# You can customize it if building a custom agent
agent = create_agent(
    model="claude-sonnet-4-5-20250929",
    middleware=[
        FilesystemMiddleware(
            backend=None,  # 可选：自定义后端（默认为 StateBackend）
            system_prompt="Write to the filesystem when...",  # 可选的系统提示自定义添加
            custom_tool_descriptions={
                "ls": "Use the ls tool when...",
                "read_file": "Use the read_file tool to..."
            }  # 可选：文件系统工具的自定义描述
        ),
    ],
)
```




### 短期与长期文件系统

默认情况下，这些工具写入您的图状态中的本地"文件系统"。要启用跨线程的持久化存储，请配置一个将特定路径（如 `/memories/`）路由到 `StoreBackend` 的 `CompositeBackend`。

```python
from langchain.agents import create_agent
from deepagents.middleware import FilesystemMiddleware
from deepagents.backends import CompositeBackend, StateBackend, StoreBackend
from langgraph.store.memory import InMemoryStore

store = InMemoryStore()

agent = create_agent(
    model="claude-sonnet-4-5-20250929",
    store=store,
    middleware=[
        FilesystemMiddleware(
            backend=lambda rt: CompositeBackend(
                default=StateBackend(rt),
                routes={"/memories/": StoreBackend(rt)}
            ),
            custom_tool_descriptions={
                "ls": "Use the ls tool when...",
                "read_file": "Use the read_file tool to..."
            }  # Optional: Custom descriptions for filesystem tools
        ),
    ],
)
```




当您为 `/memories/` 配置带有 `StoreBackend` 的 `CompositeBackend` 时，任何以 **/memories/** 为前缀的文件都会保存到持久化存储中，并在不同线程之间存活。没有此前缀的文件保留在临时状态存储中。

## 子代理中间件

将任务移交给子代理可以隔离上下文，保持主（监督）代理的上下文窗口干净，同时仍然深入处理任务。

子代理中间件允许您通过 `task` 工具提供子代理。

```python
from langchain.tools import tool
from langchain.agents import create_agent
from deepagents.middleware.subagents import SubAgentMiddleware


@tool
def get_weather(city: str) -> str:
    """Get the weather in a city."""
    return f"The weather in {city} is sunny."

agent = create_agent(
    model="claude-sonnet-4-5-20250929",
    middleware=[
        SubAgentMiddleware(
            default_model="claude-sonnet-4-5-20250929",
            default_tools=[],
            subagents=[
                {
                    "name": "weather",
                    "description": "This subagent can get weather in cities.",
                    "system_prompt": "Use the get_weather tool to get the weather in a city.",
                    "tools": [get_weather],
                    "model": "gpt-4o",
                    "middleware": [],
                }
            ],
        )
    ],
)
```




子代理使用**名称**、**描述**、**系统提示**和**工具**定义。您还可以为子代理提供自定义**模型**或额外的**中间件**。当您想为子代理提供额外的状态键以与主代理共享时，这特别有用。

对于更复杂的用例，您还可以提供自己的预构建 LangGraph 图作为子代理。

```python
from langchain.agents import create_agent
from deepagents.middleware.subagents import SubAgentMiddleware
from deepagents import CompiledSubAgent
from langgraph.graph import StateGraph

# Create a custom LangGraph graph
def create_weather_graph():
    workflow = StateGraph(...)
    # Build your custom graph
    return workflow.compile()

weather_graph = create_weather_graph()

# Wrap it in a CompiledSubAgent
weather_subagent = CompiledSubAgent(
    name="weather",
    description="This subagent can get weather in cities.",
    runnable=weather_graph
)

agent = create_agent(
    model="claude-sonnet-4-5-20250929",
    middleware=[
        SubAgentMiddleware(
            default_model="claude-sonnet-4-5-20250929",
            default_tools=[],
            subagents=[weather_subagent],
        )
    ],
)
```




除了任何用户定义的子代理外，主代理始终可以访问 `general-purpose` 子代理。此子代理具有与主代理相同的指令和所有可访问的工具。`general-purpose` 子代理的主要目的是上下文隔离——主代理可以将复杂任务委托给此子代理，并获得简洁的答案，而不会因中间工具调用而膨胀。

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss\deepagents\middleware.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
